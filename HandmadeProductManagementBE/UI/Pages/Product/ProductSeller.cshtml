@page
@using UI.Pages.Shared
@model UI.Pages.Product.ProductSellerModel
@{
    ViewData["Title"] = "Product Seller List";
}
@Html.AntiForgeryToken()

<h1 class="text-3xl font-bold mb-4">Product List</h1>
@{
    var errorModel = new ErrorMessageModel
            {
                ErrorMessage = Model.ErrorMessage,
                ErrorDetail = Model.ErrorDetail
            };
}
@if (!string.IsNullOrEmpty(Model.ErrorMessage))
{
    <partial name="_ErrorMessage" model="errorModel" />
}


<div class="search-filter">
    <form method="get" class="flex space-x-4 items-center">
        <input class="border border-gray-300 rounded-md p-2" type="text" name="Name" placeholder="Search by name" value="@Request.Query["Name"]" onchange="this.form.submit();" />
        <select name="CategoryId" class="border border-gray-300 rounded-md p-2">
            <option value="">Select Category</option>
            @if (Model.Categories != null && Model.Categories.Any())
            {
                foreach (var category in Model.Categories)
                {
                    var isSelected = Request.Query["CategoryId"] == category.Id.ToString();
                    if (isSelected)
                    {
                        <option value="@category.Id" selected>@category.Name</option>
                    }
                    else
                    {
                        <option value="@category.Id">@category.Name</option>
                    }
                }
            }
        </select>
        @{
            var selectedStatus = Request.Query["Status"].ToString();
        }

        <select name="Status" class="border border-gray-300 rounded-md p-2">
            @if (string.IsNullOrEmpty(selectedStatus))
            {
                <option value="" selected>Select Status</option>
            }
            else
            {
                <option value="">Select Status</option>
            }

            @if (selectedStatus == "Available")
            {
                <option value="Available" selected>Available</option>
            }
            else
            {
                <option value="Available">Available</option>
            }

            @if (selectedStatus == "OutOfStock")
            {
                <option value="OutOfStock" selected>Out Of Stock</option>
            }
            else
            {
                <option value="OutOfStock">Out Of Stock</option>
            }
        </select>
        <input class="border border-gray-300 rounded-md p-2" type="number" name="MinRating" placeholder="Min Rating" min="0" max="5" value="@Request.Query["MinRating"]" />

        <div class="flex items-center space-x-4">
            <label class="flex items-center">
                <input type="radio" id="sortByPrice" name="SortOption" value="SortByPrice"
                @(Request.Query["SortOption"] == "SortByPrice" ? "checked" : "") onchange="this.form.submit();" />
                <span class="ml-2">Sort by Price</span>
            </label>

            <label class="flex items-center">
                <input type="radio" id="sortByRating" name="SortOption" value="SortByRating"
                @(Request.Query["SortOption"] == "SortByRating" ? "checked" : "") onchange="this.form.submit();" />
                <span class="ml-2">Sort by Rating</span>
            </label>
        </div>



        <label class="flex items-center">
            <span class="mr-2">Sort Descending:</span>
            <input type="checkbox" name="sortDescending" value="true"
            @(Request.Query["SortDescending"] == "true" ? "checked" : "") onchange="this.form.submit();" />
        </label>

        <button type="submit" class="bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600">Search</button>
        <button type="button" onclick="openAddProductModal()"
                class="bg-green-500 text-white py-2 px-4 rounded-md hover:bg-green-600">
            Add Product
        </button>
    </form>
</div>

<!-- Product List -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 mt-8">
    @if (Model.Products != null && Model.Products.Any())
    {
        foreach (var product in Model.Products)
        {
            <div class="border rounded-lg shadow-md p-4">
                <div class="aspect-w-1 aspect-h-1 mb-4">
                    @if (!string.IsNullOrEmpty(product.ProductImageUrl))
                    {
                        <img src="@product.ProductImageUrl" alt="@product.Name" class="object-cover rounded-md w-full h-48" />
                    }
                    else
                    {
                        <div class="bg-gray-200 rounded-md w-full h-48 flex items-center justify-center">
                            <span class="text-gray-500">No image</span>
                        </div>
                    }
                </div>
                <h3 class="text-lg font-semibold">@product.Name</h3>
                @*                 <p class="text-gray-600 text-sm mb-2">@product.Category?.Name</p>
        *@                <p class="text-gray-800 font-medium">$@product.LowestPrice.ToString("F2")</p>
                <div class="flex items-center mt-2">
                    <span class="text-yellow-400">★</span>
                    <span class="ml-1">@product.Rating.ToString("F1")</span>
                    @*                     <span class="text-gray-500 ml-2">(@product.ReviewCount reviews)</span>
            *@
                </div>
                <div class="mt-3 flex justify-between items-center">
                    <div class="text-sm text-gray-500 mt-2">
                        <span id="status-label-@product.Id" class="px-2 py-1 rounded-full text-sm @(product.Status == "Available" ? "bg-green-100 text-green-800" : "bg-red-100 text-red-800")">@product.Status</span>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="toggleProductStatus('@product.Id', '@product.Status', this)"
                                class="@(product.Status == "Available" ? "bg-yellow-500 hover:bg-yellow-600 text-white py-1 px-3 rounded-md" : "bg-green-500 hover:bg-green-600 text-white py-1 px-3 rounded-md")">
                            @(product.Status == "Available" ? "Deactivate" : "Activate")
                        </button>
                        <button onclick="loadProductDetails('@product.Id')"
                                class="bg-blue-500 text-white py-1 px-3 rounded-md hover:bg-blue-600">
                            Edit
                        </button>
                        <button onclick="deleteProduct('@product.Id')"
                                class="bg-red-500 text-white py-1 px-3 rounded-md hover:bg-red-600">
                            Delete
                        </button>
                    </div>
                </div>
            </div>
        }
    }
    else
    {
        <div class="col-span-full text-center py-8">
            <p class="text-gray-500">No products found.</p>
        </div>
    }
</div>

@{
    var paginationModel = new UI.Pages.Shared.PaginationModel
            {
                PageNumber = Model.PageNumber,
                PageSize = Model.PageSize,

                CurrentFilter = Model.CurrentFilters,
                HasNextPage = Model.HasNextPage

            };
}

<partial name="~/Pages/Shared/_Pagination.cshtml" model="paginationModel" />

<!-- Add Product Modal -->
<div id="addProductModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-3/4 max-h-[90vh] overflow-y-auto">
        <h2 class="text-2xl font-bold mb-4 text-center">Add New Product</h2>

        <form asp-page-handler="CreateProduct" method="post" enctype="multipart/form-data" class="space-y-4">
            <!-- Basic Product Information -->
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Product Name</label>
                    <input type="text" asp-for="ProductCreation.Name" required
                           class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Category</label>
                    <select asp-for="ProductCreation.CategoryId"
                            asp-items="@(new SelectList(Model.Categories, "Id", "Name"))"
                            required
                            id="categorySelect"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                        <option value="">Select Category</option>
                    </select>
                </div>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700">Description</label>
                <textarea asp-for="ProductCreation.Description" rows="3"
                          class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></textarea>
            </div>

            <!-- Existing Variations Section -->
            <div id="existingVariationsContainer" class="border-t pt-4">
                <h3 class="text-lg font-medium mb-2">Existing Variations</h3>
                <div id="existingVariationsList"></div>
            </div>

            <!-- New Variations Section -->
            <div id="newVariationsContainer"></div>
            <button type="button" id="addNewVariationBtn" class="btn btn-secondary mb-4">
                Add New Variation
            </button>

            <!-- Update your variation combination section -->
            <div id="variationCombinationContainer" class="border-t pt-4">
                <h3 class="text-lg font-medium mb-2">Variation Combinations</h3>
            </div>

            <!-- Image Upload -->
            <div class="border-t pt-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Product Images</label>
                <input type="file" id="productImages" name="ProductImages" multiple accept="image/*"
                       onchange="previewImages(this)" class="hidden" />
                <button type="button" onclick="document.getElementById('productImages').click()"
                        class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">
                    Choose Images
                </button>
                <div id="imagePreviewContainer" class="grid grid-cols-4 gap-4 mt-4"></div>
            </div>

            <div class="flex justify-end space-x-4 pt-4 border-t">
                <button type="button" onclick="closeAddProductModal()"
                        class="bg-gray-500 text-white px-6 py-2 rounded-md hover:bg-gray-600">
                    Cancel
                </button>
                <button type="submit"
                        class="bg-blue-500 text-white px-6 py-2 rounded-md hover:bg-blue-600">
                    Create Product
                </button>
            </div>
        </form>
    </div>
</div>

<!-- Edit Product Modal -->
<div id="editProductModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-3/4 max-h-[90vh] overflow-y-auto">
        <h2 class="text-2xl font-bold mb-4 text-center">Edit Product</h2>
        <!-- Basic Information Form -->
        <form method="post" asp-page-handler="UpdateBasicInfo" id="basicInfoForm" class="space-y-4 mb-8 border-b pb-8">
            @Html.AntiForgeryToken()
            <input type="hidden" name="productId" id="editProductId" />
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Product Name</label>
                    <input type="text" asp-for="ProductUpdate.Name" id="editProductName"
                           class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
                    <span asp-validation-for="ProductUpdate.Name" class="text-red-500 text-sm"></span>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Category</label>
                    <select asp-for="ProductUpdate.CategoryId" id="editCategorySelect"
                            asp-items="@(new SelectList(Model.Categories, "Id", "Name"))"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                        <option value="">Select Category</option>
                    </select>
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">Description</label>
                <textarea asp-for="ProductUpdate.Description" id="editProductDescription" rows="3"
                          class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></textarea>
            </div>
            <div class="flex justify-end">
                <button type="submit"
                        class="px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md">
                    Save Basic Info
                </button>
            </div>
        </form>
        <!-- Product Items Form -->
        <form method="post" asp-page-handler="UpdateProductItems" id="productItemsForm" class="space-y-4">
            @Html.AntiForgeryToken()
            <input type="hidden" name="productId" id="editProductIdForItems" />
            <h3 class="text-lg font-medium text-gray-900 mb-4">Product Items</h3>
            <div id="productItemsContainer" class="space-y-4">
                <!-- Product items will be populated here -->
            </div>
            <div class="flex justify-end mt-4">
                <button type="submit"
                        class="px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md">
                    Save Product Items
                </button>
            </div>
        </form>
        <div class="flex justify-end space-x-3 pt-4 mt-8 border-t">
            <button type="button" onclick="closeEditModal()"
                    class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md">
                Close
            </button>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        async function toggleProductStatus(productId, currentStatus, button) {
            try {
                const isAvailable = currentStatus === "Available" ? false : true;
                const response = await fetch(`?handler=ToggleProductStatus&productId=${productId}&isAvailable=${isAvailable}`, {
                    method: 'POST',
                    headers: {
                        '__RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Update the product status label and button text immediately
                    const statusLabel = document.getElementById(`status-label-${productId}`);
                    const newStatus = isAvailable ? "Available" : "Unavailable";
                    statusLabel.textContent = newStatus;

                    // Update the status label class for color change
                    if (isAvailable) {
                        statusLabel.classList.remove("bg-red-100", "text-red-800");
                        statusLabel.classList.add("bg-green-100", "text-green-800");
                    } else {
                        statusLabel.classList.remove("bg-green-100", "text-green-800");
                        statusLabel.classList.add("bg-red-100", "text-red-800");
                    }

                    // Update the button text and style
                    button.textContent = isAvailable ? "Deactivate" : "Activate";
                    button.className = isAvailable ? "bg-yellow-500 hover:bg-yellow-600 text-white py-1 px-3 rounded-md"
                        : "bg-green-500 hover:bg-green-600 text-white py-1 px-3 rounded-md";

                    // Update the button's currentStatus value for next toggle
                    button.setAttribute("onclick", `toggleProductStatus('${productId}', '${newStatus}', this)`);
                } else {
                    alert(data.error || 'Failed to update product status');
                }
            } catch (error) {
                console.error('Error details:', error);
                alert('An unexpected error occurred while updating the product status.');
            }
        }

        // Delete Product Function
        async function deleteProduct(productId) {
            if (!confirm('Are you sure you want to delete this product?')) {
                return;
            }

            try {
                const token = document.querySelector('input[name="__RequestVerificationToken"]').value;
                const response = await fetch(`?handler=DeleteProduct&id=${productId}`, {
                    method: 'POST',
                    headers: {
                        'RequestVerificationToken': token
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete product');
                }

                alert('Product deleted successfully!');
                window.location.reload();
            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while deleting the product');
            }
        }

        //Add Product
        // Global state management
        const state = {
            existingVariationsData: [],
            selectedVariations: [],
            variationCombinations: []
        };

        // Utility functions
        const generateCombinations = (variations) => {
            if (variations.length === 0) return [];
            if (variations.length === 1) return variations[0].map(v => [v]);

            const result = [];
            const combine = (current, rest) => {
                if (rest.length === 0) {
                    result.push(current);
                    return;
                }
                rest[0].forEach(item => {
                    combine([...current, item], rest.slice(1));
                });
            };

            combine([], variations);
            return result;
        };

        const saveNewVariation = async (variationRow) => {
            try {
                const nameInput = variationRow.querySelector('input[name*=".Name"]');
                const optionInputs = variationRow.querySelectorAll('input[name*=".Options"]');
                const variationName = nameInput.value.trim();
                const options = Array.from(optionInputs).map(input => input.value.trim()).filter(Boolean);

                if (!variationName || options.length === 0) {
                    alert('Please enter variation name and at least one option');
                    return;
                }

                const categoryId = document.getElementById('categorySelect').value;
                const response = await fetch(`?handler=CategoryVariations&categoryId=${categoryId}`);
                const existingVariations = await response.json();
                const existingVariation = existingVariations.find(v =>
                    v.name.toLowerCase() === variationName.toLowerCase()
                );

                let variationId;
                let optionIds = [];

                if (existingVariation) {
                    variationId = existingVariation.id;
                    for (const option of options) {
                        const optionData = {
                            value: option,
                            variationId: variationId
                        };

                        const createOptionResponse = await fetch('?handler=CreateVariationOption', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                            },
                            body: JSON.stringify(optionData)
                        });

                        if (!createOptionResponse.ok) {
                            throw new Error('Failed to create option');
                        }

                        const optionResult = await createOptionResponse.json();
                        if (optionResult.success) {
                            optionIds.push(optionResult.optionId);
                        }
                    }
                } else {
                    const variationData = {
                        name: variationName,
                        categoryId: categoryId,
                        options: options
                    };

                    const createResponse = await fetch('?handler=CreateVariation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify(variationData)
                    });

                    if (!createResponse.ok) {
                        throw new Error('Failed to create variation');
                    }

                    const result = await createResponse.json();
                    if (result.success) {
                        variationId = result.variationId;
                        optionIds = result.optionIds;
                    } else {
                        throw new Error(result.message);
                    }
                }

                appendVariationToList(variationId, variationName, options, optionIds);
                variationRow.remove();
                updateVariationCombinations();
                alert('Variation saved successfully!');
            } catch (error) {
                console.error('Error saving variation:', error);
                alert('Failed to save variation: ' + error.message);
            }
        };

        const appendVariationToList = (variationId, variationName, options, optionIds) => {
            const variationDiv = document.createElement('div');
            variationDiv.classList.add('p-4', 'border', 'rounded-md', 'bg-gray-50', 'mb-4');
            variationDiv.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <span class="font-medium">${variationName}</span>
                    <button type="button"
                            onclick="removeExistingVariation('${variationId}')"
                            class="text-red-600 hover:text-red-800">
                        Remove
                    </button>
                </div>
                <div class="mt-2">
                    <select name="SelectedVariations"
                            data-variation-id="${variationId}"
                            data-variation-name="${variationName}"
                            class="form-select w-full rounded-md border-gray-300"
                            onchange="handleExistingVariationSelection(this)">
                        <option value="">Select ${variationName}</option>
                        ${options.map((option, index) =>
                `<option value="${optionIds[index]}">${option}</option>`
            ).join('')}
                    </select>
                </div>
            `;

            document.getElementById('existingVariationsList').appendChild(variationDiv);
        };

        const addNewVariationUI = () => {
            const container = document.getElementById('newVariationsContainer');
            const variationIndex = container.children.length;

            const newRow = document.createElement('div');
            newRow.classList.add('variation-row', 'mb-4', 'p-4', 'border', 'rounded');
            newRow.innerHTML = `
                <div class="flex items-center mb-2">
                    <label class="block text-sm font-medium text-gray-700 mr-2">Variation Name:</label>
                    <input type="text"
                           name="NewVariations[${variationIndex}].Name"
                           class="flex-grow mr-2 form-input rounded"
                           placeholder="Enter variation name"
                           required />
                    <button type="button"
                            onclick="this.closest('.variation-row').remove()"
                            class="text-red-600 hover:text-red-800">
                        Remove
                    </button>
                </div>
                <div class="variation-options">
                    <div class="option-row mb-2">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Options:</label>
                        <div class="flex items-center">
                            <input type="text"
                                   name="NewVariations[${variationIndex}].Options"
                                   class="form-input rounded flex-grow mr-2"
                                   placeholder="Enter option value"
                                   required />
                            <button type="button"
                                    onclick="addVariationOption(this.closest('.option-row'))"
                                    class="bg-blue-500 text-white px-3 py-1 rounded-md hover:bg-blue-600">
                                Add Option
                            </button>
                        </div>
                    </div>
                </div>
                <div class="mt-4">
                    <button type="button"
                            onclick="saveNewVariation(this.closest('.variation-row'))"
                            class="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600">
                        Save Variation
                    </button>
                </div>
            `;

            container.appendChild(newRow);
        };

        const validateInput = {
            price: (value) => {
                const price = parseFloat(value);
                return !isNaN(price) && price > 0;
            },
            stock: (value) => {
                const stock = parseInt(value);
                return !isNaN(stock) && stock >= 0;
            }
        };

        // Variation handling functions
        const handleExistingVariationSelection = async (selectElement) => {
            try {
                const variationId = selectElement.getAttribute('data-variation-id');
                const variationName = selectElement.getAttribute('data-variation-name');
                const optionId = selectElement.value;
                const optionName = selectElement.options[selectElement.selectedIndex].text;

                // Update state
                const existingIndex = state.existingVariationsData.findIndex(v => v.variationId === variationId);
                if (existingIndex >= 0) {
                    if (optionId) {
                        state.existingVariationsData[existingIndex] = {
                            variationId,
                            variationName,
                            optionId,
                            optionName
                        };
                    } else {
                        state.existingVariationsData.splice(existingIndex, 1);
                    }
                } else if (optionId) {
                    state.existingVariationsData.push({
                        variationId,
                        variationName,
                        optionId,
                        optionName
                    });
                }

                // Find the form using multiple selectors
                const form = selectElement.closest('form') ||
                    document.querySelector('form') ||
                    document.querySelector('[asp-page-handler="CreateProduct"]');

                if (!form) {
                    console.warn('Form not found, creating hidden input in the select element\'s parent');
                    // If no form is found, add the hidden input to the select's parent container
                    const container = selectElement.closest('.p-4') || selectElement.parentElement;

                    const hiddenInput = container.querySelector(`input[name="variation_${variationId}"]`) ||
                        document.createElement('input');

                    if (optionId) {
                        hiddenInput.type = 'hidden';
                        hiddenInput.name = `variation_${variationId}`;
                        hiddenInput.value = optionId;
                        if (!hiddenInput.parentElement) {
                            container.appendChild(hiddenInput);
                        }
                    } else if (hiddenInput.parentElement) {
                        hiddenInput.remove();
                    }
                } else {
                    // If form is found, proceed with normal hidden input handling
                    const hiddenInput = form.querySelector(`input[name="variation_${variationId}"]`) ||
                        document.createElement('input');

                    if (optionId) {
                        hiddenInput.type = 'hidden';
                        hiddenInput.name = `variation_${variationId}`;
                        hiddenInput.value = optionId;
                        if (!hiddenInput.parentElement) {
                            form.appendChild(hiddenInput);
                        }
                    } else if (hiddenInput.parentElement) {
                        hiddenInput.remove();
                    }
                }

                updateVariationCombinations();
            } catch (error) {
                console.error('Error handling variation selection:', error);
                console.log('Select element:', selectElement);
                console.log('Current state:', state);
                alert('Error updating variation selection. Please try again.');
            }
        };

        const handleNewVariationInput = (input) => {
            try {
                const variationRow = input.closest('.variation-row');
                if (!variationRow) return;

                const nameInput = variationRow.querySelector('input[name*=".Name"]');
                const optionInputs = variationRow.querySelectorAll('input[name*=".Options"]');

                if (!nameInput || !optionInputs.length) return;

                if (nameInput.value) {
                    // Remove existing variation with same name
                    state.selectedVariations = state.selectedVariations.filter(
                        v => v.variationId !== `new_${nameInput.value}`
                    );

                    // Add new options
                    optionInputs.forEach(optionInput => {
                        if (optionInput.value) {
                            state.selectedVariations.push({
                                variationId: `new_${nameInput.value}`,
                                variationName: nameInput.value,
                                optionId: `new_${optionInput.value}`,
                                optionName: optionInput.value
                            });
                        }
                    });

                    updateVariationCombinations();
                }
            } catch (error) {
                console.error('Error handling new variation input:', error);
            }
        };

        const updateVariationCombinations = () => {
            try {
                const container = document.getElementById('variationCombinationContainer');
                if (!container) return;

                container.innerHTML = '<h3 class="text-lg font-medium mb-2">Variation Combinations</h3>';

                // Group variations by name
                const groupedVariations = new Map();

                // Group existing variations
                state.existingVariationsData.forEach(v => {
                    if (!groupedVariations.has(v.variationName)) {
                        groupedVariations.set(v.variationName, []);
                    }
                    groupedVariations.get(v.variationName).push(v);
                });

                // Group new variations
                state.selectedVariations.forEach(v => {
                    if (!groupedVariations.has(v.variationName)) {
                        groupedVariations.set(v.variationName, []);
                    }
                    groupedVariations.get(v.variationName).push(v);
                });

                // Convert to array format for combination generation
                const variationsArray = Array.from(groupedVariations.values());
                if (!variationsArray.length) return;

                // Generate combinations
                const combinations = generateCombinations(variationsArray);

                combinations.forEach((combination, index) => {
                    const combinationDiv = document.createElement('div');
                    combinationDiv.classList.add('mb-4', 'p-4', 'border', 'rounded-md');

                    const optionsText = combination.map(item =>
                        `${item.variationName}: ${item.optionName}`
                    ).join(', ');

                    const optionIds = combination.map(item =>
                        item.optionId
                    ).join(',');

                    combinationDiv.innerHTML = `
                                <div class="mb-2 font-medium">${optionsText}</div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700">Price</label>
                                        <input type="number"
                                               name="VariationCombinations[${index}].Price"
                                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                               required min="0" step="0.01" />
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700">Stock</label>
                                        <input type="number"
                                               name="VariationCombinations[${index}].Stock"
                                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                               required min="0" step="1" />
                                    </div>
                                </div>
                                <input type="hidden"
                                       name="VariationCombinations[${index}].OptionIds"
                                       value="${optionIds}" />
                            `;

                    container.appendChild(combinationDiv);
                });
            } catch (error) {
                console.error('Error updating variation combinations:', error);
            }
        };

        // Category and variation loading
        const loadExistingVariations = async () => {
            try {
                const categoryId = document.getElementById('categorySelect')?.value;
                const container = document.getElementById('existingVariationsList');

                if (!container) return;
                container.innerHTML = '';

                if (!categoryId) return;

                const response = await fetch(`?handler=CategoryVariations&categoryId=${categoryId}`);
                if (!response.ok) throw new Error('Failed to load variations');

                const variations = await response.json();

                variations.forEach(variation => {
                    const variationDiv = document.createElement('div');
                    variationDiv.classList.add('p-4', 'border', 'rounded-md', 'bg-gray-50', 'mb-4');

                    variationDiv.innerHTML = `
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-medium">${variation.name}</span>
                                    <button type="button"
                                            onclick="removeExistingVariation('${variation.id}')"
                                            class="text-red-600 hover:text-red-800">
                                        Remove
                                    </button>
                                </div>
                                <div class="mt-2">
                                    <select name="SelectedVariations"
                                            data-variation-id="${variation.id}"
                                            data-variation-name="${variation.name}"
                                            class="form-select w-full rounded-md border-gray-300"
                                            onchange="handleExistingVariationSelection(this)">
                                        <option value="">Select ${variation.name}</option>
                                    </select>
                                </div>
                            `;

                    container.appendChild(variationDiv);
                    loadVariationOptions(variation.id, variationDiv.querySelector('select'));
                });
            } catch (error) {
                console.error('Error loading variations:', error);
                alert('Failed to load existing variations');
            }
        };

        const loadVariationOptions = async (variationId, selectElement) => {
            try {
                const response = await fetch(`?handler=VariationOptions&variationId=${variationId}`);
                if (!response.ok) throw new Error('Failed to load variation options');

                const options = await response.json();
                const firstOption = selectElement.options[0];
                selectElement.innerHTML = '';
                selectElement.appendChild(firstOption);

                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.id;
                    optionElement.textContent = option.value;
                    selectElement.appendChild(optionElement);
                });
            } catch (error) {
                console.error('Error loading variation options:', error);
                alert('Failed to load variation options');
            }
        };

        // Initialize the page
        document.addEventListener('DOMContentLoaded', () => {
            window.addVariationOption = addVariationOption;
            window.handleExistingVariationSelection = handleExistingVariationSelection;
            window.removeExistingVariation = removeExistingVariation;
            window.saveNewVariation = saveNewVariation;

            const categorySelect = document.getElementById('categorySelect');
            if (categorySelect) {
                categorySelect.addEventListener('change', loadExistingVariations);
                if (categorySelect.value) {
                    loadExistingVariations();
                }
            }

            const addVariationBtn = document.getElementById('addNewVariationBtn');
            if (addVariationBtn) {
                addVariationBtn.addEventListener('click', addNewVariationUI);
            }

            const form = document.querySelector('form[asp-page-handler="CreateProduct"]');
            if (form) {
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (await validateForm()) {
                        submitForm(form);
                    }
                });
            }
        });
        
        // Form validation and submission
        const validateForm = async () => {
            const name = document.querySelector('input[asp-for="ProductCreation.Name"]')?.value;
            const category = document.querySelector('select[asp-for="ProductCreation.CategoryId"]')?.value;

            if (!name || !category) {
                alert('Please fill in all required fields (Name and Category)');
                return false;
            }

            const hasExistingVariations = state.existingVariationsData.length > 0;
            const hasNewVariations = state.selectedVariations.length > 0;

            if (!hasExistingVariations && !hasNewVariations) {
                alert('Please select at least one variation or create a new one');
                return false;
            }

            const combinations = document.querySelectorAll('#variationCombinationContainer > div');
            if (!combinations.length) {
                alert('Please create at least one variation combination');
                return false;
            }

            let isValid = true;
            combinations.forEach(combo => {
                const price = combo.querySelector('input[name*=".Price"]')?.value;
                const stock = combo.querySelector('input[name*=".Stock"]')?.value;

                if (!validateInput.price(price) || !validateInput.stock(stock)) {
                    isValid = false;
                }
            });

            if (!isValid) {
                alert('Please enter valid price and stock for all variation combinations');
                return false;
            }

            return true;
        };

        const submitForm = async (form) => {
            try {
                const formData = new FormData(form);
                const response = await fetch('?handler=CreateProduct', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                if (response.redirected) {
                    window.location.href = response.url;
                    return;
                }

                const result = await response.json();
                if (result.success) {
                    alert('Product created successfully!');
                    window.location.reload();
                } else {
                    alert(result.message || 'Failed to create product. Please try again.');
                }
            } catch (error) {
                console.error('Error submitting form:', error);
                alert('An error occurred while creating the product. Please try again.');
            }
        };

        // Additional helper functions (continued)
        function addVariationOption(button) {
            const optionValue = prompt('Enter option value:');
            if (!optionValue) return;

            const variationOptions = button.closest('.variation-row').querySelector('.variation-options');
            const optionRow = document.createElement('div');
            optionRow.className = 'option-row flex items-center gap-2';

            optionRow.innerHTML = `
                <label class="inline-flex items-center p-2 border rounded-md bg-white flex-grow">
                    <input type="checkbox"
                           class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50"
                           onchange="handleVariationOptionChange(this)"
                           value="${optionValue}" />
                    <span class="ml-2">${optionValue}</span>
                </label>
                <button type="button"
                        onclick="removeVariationOption(this)"
                        class="bg-red-500 text-white p-2 rounded-md hover:bg-red-600">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            `;

            variationOptions.appendChild(optionRow);
            updateVariationCombinations();
        }

        const removeExistingVariation = (variationId) => {
            try {
                // Remove from state
                state.existingVariationsData = state.existingVariationsData.filter(
                    v => v.variationId !== variationId
                );

                // Remove from DOM
                const variationElement = document.querySelector(`select[data-variation-id="${variationId}"]`)
                    ?.closest('.p-4');
                if (variationElement) {
                    variationElement.remove();
                }

                // Remove hidden input
                const hiddenInput = document.querySelector(`input[name="variation_${variationId}"]`);
                if (hiddenInput) {
                    hiddenInput.remove();
                }

                updateVariationCombinations();
            } catch (error) {
                console.error('Error removing variation:', error);
            }
        };

        function displayCurrentImages(images) {
            const container = document.getElementById('currentImagesContainer');
            if (!container) {
                console.error('Current images container not found');
                return;
            }

            // Clear existing images
            container.innerHTML = '';

            // Display each image
            images.forEach((image, index) => {
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'relative';

                const img = document.createElement('img');
                img.src = image.imageUrl; // Adjust this based on your image object structure
                img.alt = `Product Image ${index + 1}`;
                img.className = 'w-full h-32 object-cover rounded-md';

                // Delete button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'absolute top-0 right-0 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center m-1';
                deleteButton.innerHTML = '×';
                deleteButton.onclick = () => removeImage(image.id); // Adjust based on your image object structure

                imageWrapper.appendChild(img);
                imageWrapper.appendChild(deleteButton);
                container.appendChild(imageWrapper);
            });
        }

        function removeImage(imageId) {
            if (confirm('Are you sure you want to remove this image?')) {
                // Add your image removal logic here
                console.log(`Removing image with ID: ${imageId}`);
            }
        }

        // Image preview functionality
        function previewImages(input) {
            const imagePreviewContainer = document.getElementById('imagePreviewContainer');
            imagePreviewContainer.innerHTML = '';

            if (input.files) {
                Array.from(input.files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const imgWrapper = document.createElement('div');
                        imgWrapper.classList.add('relative');
                        imgWrapper.innerHTML = `
                                        <img src="${e.target.result}" class="w-full h-32 object-cover rounded-md" />
                                        <button type="button" onclick="removeImage(this)"
                                                class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center">
                                            ✖
                                        </button>
                                    `;
                        imagePreviewContainer.appendChild(imgWrapper);
                    };
                    reader.readAsDataURL(file);
                });
            }
        }

        // Function to remove an image from preview
        function removeImage(button) {
            const imgWrapper = button.closest('div');
            const fileInput = document.getElementById('productImages');
            const files = Array.from(fileInput.files);

            // Remove the corresponding file from FileList
            const index = Array.from(imgWrapper.parentNode.children).indexOf(imgWrapper);
            files.splice(index, 1);

            // Update FileList
            const dataTransfer = new DataTransfer();
            files.forEach(file => dataTransfer.items.add(file));
            fileInput.files = dataTransfer.files;

            // Remove preview
            imgWrapper.remove();
        }

        // Modal functionality
        function openAddProductModal() {
            document.getElementById('addProductModal').classList.remove('hidden');
            document.getElementById('addProductModal').classList.add('flex');
        }

        function closeAddProductModal() {
            document.getElementById('addProductModal').classList.remove('flex');
            document.getElementById('addProductModal').classList.add('hidden');
        }

























        //Edit Product
        const editProductState = {
            productItems: []
        };

        async function loadProductDetails(productId) {
            try {
                const response = await fetch(`?handler=ProductDetails&productId=${productId}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });
                if (!response.ok) {
                    throw new Error('Failed to load product data');
                }
                const data = await response.json();
                if (data.success && data.product) {
                    populateEditForm(data.product);
                    populateProductItems(data.product.productItems);
                    openEditProductModal();
                }
            } catch (error) {
                console.error('Error loading product details:', error);
                alert('Failed to load product details: ' + error.message);
            }
        }

        function populateEditForm(product) {
            if (!product) return;
            document.getElementById('editProductId').value = product.id;
            document.getElementById('editProductIdForItems').value = product.id;
            document.getElementById('editProductName').value = product.name || '';
            document.getElementById('editProductDescription').value = product.description || '';
            document.getElementById('editCategorySelect').value = product.categoryId || '';
        }

        function populateProductItems(productItems) {
            const container = document.getElementById('productItemsContainer');
            container.innerHTML = '';
            editProductState.productItems = productItems || [];
            editProductState.productItems.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-4 border rounded-md';
                itemDiv.innerHTML = `
                            <input type="hidden" name="ProductItemUpdates[${index}].ItemId" value="${item.id}" />
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700">Quantity in Stock</label>
                                    <input type="number"
                                           name="ProductItemUpdates[${index}].QuantityInStock"
                                           class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                           value="${item.quantityInStock}"
                                           min="0" />
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700">Price</label>
                                    <input type="number"
                                           name="ProductItemUpdates[${index}].Price"
                                           class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                           value="${item.price}"
                                           min="0" />
                                </div>
                            </div>
                        `;
                container.appendChild(itemDiv);
            });
        }

        function openEditProductModal() {
            const modal = document.getElementById('editProductModal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function closeEditModal() {
            const modal = document.getElementById('editProductModal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        // Add form submission handlers
        // Add form submission handlers with improved error checking
        document.getElementById('basicInfoForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const form = e.target;
            try {
                const response = await fetch(form.action, {
                    method: 'POST',
                    body: new FormData(form),
                    headers: {
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        alert('Product information updated successfully');
                        closeEditModal();
                        location.reload(); // Refresh the page
                    } else {
                        alert(result.message || 'Failed to update product information');
                    }
                } else {
                    console.error('Non-JSON response received');
                    alert('An error occurred while updating the product');
                }
            } catch (error) {
                console.error('Error updating product:', error);
                alert('An error occurred while updating the product');
            }
        });

        document.getElementById('productItemsForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const form = e.target;
            try {
                const response = await fetch(form.action, {
                    method: 'POST',
                    body: new FormData(form),
                    headers: {
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        alert('Product items updated successfully');
                        closeEditModal();
                        location.reload(); // Refresh the page
                    } else {
                        alert(result.message || 'Failed to update product items');
                    }
                } else {
                    console.error('Non-JSON response received');
                    alert('An error occurred while updating the product items');
                }
            } catch (error) {
                console.error('Error updating product items:', error);
                alert('An error occurred while updating the product items');
            }
        });
    </script>
}
