@page
@using HandmadeProductManagement.Core.Common
@model UI.Pages.Seller.ShopModel
@{
    ViewData["Title"] = "My Shop";
}
@Html.AntiForgeryToken()
@using UI.Pages.Shared
@{
    var errorModel = new ErrorMessageModel
            {
                ErrorMessage = Model.ErrorMessage,
                ErrorDetail = Model.ErrorDetail
            };
    var token = HttpContext.Session.GetString("Token");
}
@if (!string.IsNullOrEmpty(Model.ErrorMessage) && Model.ErrorMessage != "NotFoundException")
{
    <partial name="_ErrorMessage" model="errorModel" />
}

<script>
    const apiBaseUrl = '@Constants.ApiBaseUrl';
    var tokenFromRazor = '@token';

    // Kiểm tra nếu token tồn tại và lưu vào localStorage
    if (tokenFromRazor) {
        localStorage.setItem('authToken', tokenFromRazor);
    } else {
        console.log("Token không tồn tại.");
    }
    const authToken = localStorage.getItem('authToken');
    const requestVerificationToken = document.querySelector('input[name="__RequestVerificationToken"]').value;
</script>

@if (Model.ErrorMessage == "NotFoundException")
{
    <div class="flex h-screen flex-col items-center justify-center text-center">
        <h2 class="mb-4 text-6xl font-semibold">Open Your Own Shop Today!</h2>
        <button onclick="openShopModal()" class="rounded-lg bg-blue-500 px-6 py-3 font-bold text-white hover:bg-blue-600">
            Open Your Shop
        </button>
    </div>

    <!-- Shop creation modal -->
    <div id="shopModal" class="fixed inset-0 flex hidden items-center justify-center bg-gray-900 bg-opacity-50">
        <div class="w-full max-w-md rounded-lg bg-white p-8">
            <h3 class="mb-4 text-xl font-semibold">Create Your Shop</h3>
            <form method="post" id="shopForm" asp-page-handler="CreateShop">
                <div class="mb-4">
                    <label class="mb-2 block font-bold text-gray-700" for="shopName">Shop Name</label>
                    <input type="text" id="updateShopName" name="ShopName"
                           class="w-full rounded-md border border-gray-300 p-2"
                           value="@Model.Shop.Name" required
                           pattern="^[A-Za-z0-9À-ỹáàảãạắằẳẵặéèẻẽẹíìỉĩịóòỏõọốồổỗộúùủũụưáàảãạắằẳẵặýỳỷỹỵđĐ\s]+$"
                           title="Shop Name only has letters and numbers" />
                </div>
                <div class="mb-4">
                    <label class="mb-2 block font-bold text-gray-700" for="shopDescription">Description</label>
                    <textarea id="shopDescription" name="ShopDescription" class="w-full rounded-md border border-gray-300 p-2" required></textarea>
                </div>
                <div class="flex justify-end space-x-4">
                    <button type="button" onclick="closeShopModal()" class="rounded-md bg-gray-300 px-4 py-2 text-gray-700 hover:bg-gray-400">
                        Cancel
                    </button>
                    <button type="submit" class="rounded-md bg-green-500 px-4 py-2 text-white hover:bg-green-600">
                        Create Shop
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        function openShopModal() {
            document.getElementById("shopModal").classList.remove("hidden");
        }
        function closeShopModal() {
            document.getElementById("shopModal").classList.add("hidden");
        }
    </script>
}
else
{
    <div class="relative w-full bg-white px-8 py-6">
        <!-- Update Button -->
        <button onclick="openUpdateModal()" class="absolute right-4 top-4 rounded-md bg-blue-500 px-4 py-2 text-white hover:bg-blue-600">
            Update Shop Info
        </button>

        <div class="flex">
            <!-- Left half for Shop Name -->
            <div class="flex w-1/2 items-center justify-center">
                <h1 class="mb-4 text-4xl font-bold">@Model.Shop.Name</h1>
            </div>

            <!-- Right half for other shop details -->
            <div class="w-1/2 pl-6">
                <div class="mb-4 flex items-center">
                    <h2 class="mr-2 text-xl font-semibold">Rating:</h2>
                    <p>@Model.Shop.Rating</p>
                </div>

                <div class="mb-4 flex items-center">
                    <h2 class="mr-2 text-xl font-semibold">Products:</h2>
                    <p>@Model.Shop.ProductCount</p>
                </div>

                <div class="mb-4 flex items-center">
                    <h2 class="mr-2 text-xl font-semibold">Joined:</h2>
                    <p>@Model.Shop.JoinedTimeAgo</p>
                </div>
            </div>
        </div>

        <!-- Full-width description section -->
        <div class="mt-6">
            <h2 class="text-xl font-semibold">Description</h2>
            <span class="text-gray-600">@Model.Shop.Description</span>
        </div>
    </div>

    <!-- Update Shop Modal -->
    <div id="updateShopModal" class="fixed inset-0 z-50 flex hidden items-center justify-center bg-gray-900 bg-opacity-50">
        <div class="w-full max-w-md rounded-lg bg-white p-8">
            <h3 class="mb-4 text-xl font-semibold">Update Shop Info</h3>
            @if (!string.IsNullOrEmpty(Model.ErrorMessage))
            {
                <div class="text-red-500">@Model.ErrorMessage</div>
            }
            <form method="post" id="updateShopForm" asp-page-handler="UpdateShop">
                <div class="mb-4">
                    <label class="mb-2 block font-bold text-gray-700" for="updateShopName">Shop Name</label>
                    <input type="text" id="updateShopName" name="ShopName"
                           class="w-full rounded-md border border-gray-300 p-2"
                           value="@Model.Shop.Name" required
                           pattern="^[A-Za-z0-9À-ỹáàảãạắằẳẵặéèẻẽẹíìỉĩịóòỏõọốồổỗộúùủũụưáàảãạắằẳẵặýỳỷỹỵđĐ\s]+$"
                           title="Shop Name only has letters (including Vietnamese characters), numbers, and spaces" />
                </div>
                <div class="mb-4">
                    <label class="mb-2 block font-bold text-gray-700" for="updateShopDescription">Description</label>
                    <textarea id="updateShopDescription" name="ShopDescription" class="w-full rounded-md border border-gray-300 p-2" required>@Model.Shop.Description</textarea>
                </div>
                <div class="flex justify-end space-x-4">
                    <button type="button" onclick="closeUpdateModal()" class="rounded-md bg-gray-300 px-4 py-2 text-gray-700 hover:bg-gray-400">
                        Cancel
                    </button>
                    <button type="submit" class="rounded-md bg-green-500 px-4 py-2 text-white hover:bg-green-600">
                        Update Shop
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        function openUpdateModal() {
            document.getElementById("updateShopModal").classList.remove("hidden");
        }

        function closeUpdateModal() {
            document.getElementById("updateShopModal").classList.add("hidden");
        }
    </script>

    <h1 class="mb-4 mt-4 text-3xl font-bold">Product List</h1>

    <div class="search-filter">
        <form method="get" class="flex items-center space-x-4">
            <input class="rounded-md border border-gray-300 p-2" type="text" name="Name" placeholder="Search by name" value="@Request.Query["Name"]" onchange="this.form.submit();" />
            <select name="CategoryId" class="rounded-md border border-gray-300 p-2">
                <option value="">Select Category</option>
                @if (Model.Categories != null && Model.Categories.Any())
                {
                    foreach (var category in Model.Categories)
                    {
                        var isSelected = Request.Query["CategoryId"] == category.Id.ToString();
                        if (isSelected)
                        {
                            <option value="@category.Id" selected>@category.Name</option>
                        }
                        else
                        {
                            <option value="@category.Id">@category.Name</option>
                        }
                    }
                }
            </select>
            @{
                var selectedStatus = Request.Query["Status"].ToString();
            }

            <select name="Status" class="rounded-md border border-gray-300 p-2">
                @if (string.IsNullOrEmpty(selectedStatus))
                {
                    <option value="" selected>Select Status</option>
                }
                else
                {
                    <option value="">Select Status</option>
                }

                @if (selectedStatus == "Available")
                {
                    <option value="Available" selected>Available</option>
                }
                else
                {
                    <option value="Available">Available</option>
                }

                @if (selectedStatus == "OutOfStock")
                {
                    <option value="OutOfStock" selected>Out Of Stock</option>
                }
                else
                {
                    <option value="OutOfStock">Out Of Stock</option>
                }
            </select>
            <input class="rounded-md border border-gray-300 p-2" type="number" name="MinRating" placeholder="Min Rating" min="0" max="5" value="@Request.Query["MinRating"]" />

            <div class="flex items-center space-x-4">
                <label class="flex items-center">
                    <input type="radio" id="sortByPrice" name="SortOption" value="SortByPrice"
                    @(Request.Query["SortOption"] == "SortByPrice" ? "checked" : "") onchange="this.form.submit();" />
                    <span class="ml-2">Sort by Price</span>
                </label>

                <label class="flex items-center">
                    <input type="radio" id="sortByRating" name="SortOption" value="SortByRating"
                    @(Request.Query["SortOption"] == "SortByRating" ? "checked" : "") onchange="this.form.submit();" />
                    <span class="ml-2">Sort by Rating</span>
                </label>
            </div>



            <label class="flex items-center">
                <span class="mr-2">Sort Descending:</span>
                <input type="checkbox" name="sortDescending" value="true"
                @(Request.Query["SortDescending"] == "true" ? "checked" : "") onchange="this.form.submit();" />
            </label>

            <button type="submit" class="rounded-md bg-blue-500 px-4 py-2 text-white hover:bg-blue-600">Search</button>
            <button type="button" onclick="openAddProductModal()"
                    class="rounded-md bg-green-500 px-4 py-2 text-white hover:bg-green-600">
                Add Product
            </button>
        </form>
    </div>

    <!-- Product List -->
    <div class="grid-cols-1 mt-8 grid gap-6 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
        @if (Model.Products != null && Model.Products.Any())
        {
            foreach (var product in Model.Products)
            {
                <div class="rounded-lg border p-4 shadow-md">
                    <div class="aspect-w-1 aspect-h-1 mb-4">
                        @if (!string.IsNullOrEmpty(product.ProductImageUrl))
                        {
                            <img src="@product.ProductImageUrl" alt="@product.Name" class="h-48 w-full rounded-md object-cover" />
                        }
                        else
                        {
                            <div class="flex h-48 w-full items-center justify-center rounded-md bg-gray-200">
                                <span class="text-gray-500">No image</span>
                            </div>
                        }
                    </div>
                    <h3 class="text-lg font-semibold">@product.Name</h3>
                    @*                 <p class="mb-2 text-sm text-gray-600">@product.Category?.Name</p>
        *@                <p class="font-medium text-gray-800">₫@product.LowestPrice.ToString("N0").Replace(",", ".")</p>
                    <div class="mt-2 flex items-center">
                        <span class="text-yellow-400">★</span>
                        <span class="ml-1">@product.Rating.ToString("F1")</span>
                        @*                     <span class="ml-2 text-gray-500">(@product.ReviewCount reviews)</span>
            *@
                    </div>
                    <div class="mt-3 flex items-center justify-between">
                        <div class="mt-2 text-sm text-gray-500">
                            <span id="status-label-@product.Id" class="rounded-full px-2 py-1 text-sm @(product.Status == "Available" ? "bg-green-100 text-green-800" : "bg-red-100 text-red-800")">@product.Status</span>
                        </div>
                        <div class="flex space-x-2">
                            <button onclick="toggleProductStatus('@product.Id', '@product.Status', this)"
                                    class="@(product.Status == "Available" ? "bg-yellow-500 hover:bg-yellow-600 text-white py-1 px-3 rounded-md" : "bg-green-500 hover:bg-green-600 text-white py-1 px-3 rounded-md")">
                                @(product.Status == "Available" ? "Deactivate" : "Activate")
                            </button>
                            <button onclick="loadProductDetails('@product.Id')"
                                    class="rounded-md bg-blue-500 px-3 py-1 text-white hover:bg-blue-600">
                                Edit
                            </button>
                            <button onclick="deleteProduct('@product.Id')"
                                    class="rounded-md bg-red-500 px-3 py-1 text-white hover:bg-red-600">
                                Delete
                            </button>
                        </div>
                    </div>
                </div>
            }
        }
        else
        {
            <div class="col-span-full py-8 text-center">
                <p class="text-gray-500">No products found.</p>
            </div>
        }
    </div>
}

@{
    var paginationModel = new UI.Pages.Shared.PaginationModel
            {
                PageNumber = Model.PageNumber,
                PageSize = Model.PageSize,

                CurrentFilter = Model.CurrentFilters,
                HasNextPage = Model.HasNextPage

            };
}

@if (string.IsNullOrEmpty(Model.ErrorMessage))
{
    <partial name="~/Pages/Shared/_Pagination.cshtml" model="paginationModel" />
}

<!-- Add Product Modal -->
<div id="addProductModal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-50">
    <div class="max-h-[90vh] w-3/4 overflow-y-auto rounded-lg bg-white p-6">
        <h2 class="mb-4 text-center text-2xl font-bold">Add New Product</h2>

        <form asp-page-handler="CreateProduct" method="post" enctype="multipart/form-data" class="space-y-4">
            <!-- Basic Product Information -->
            <div class="grid-cols-2 grid gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Product Name</label>
                    <input type="text" asp-for="ProductCreation.Name" required
                           class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Category</label>
                    <select asp-for="ProductCreation.CategoryId"
                            asp-items="@(new SelectList(Model.Categories, "Id", "Name"))"
                            required
                            id="categorySelect"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                        <option value="">Select Category</option>
                    </select>
                </div>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700">Description</label>
                <textarea asp-for="ProductCreation.Description" rows="3"
                          class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></textarea>
            </div>

            <!-- Existing Variations Section -->
            <div id="existingVariationsContainer" class="border-t pt-4">
                <h3 class="mb-2 text-lg font-medium">Existing Variations</h3>
                <div id="existingVariationsList"></div>
            </div>

            <!-- New Variations Section -->
            <div id="newVariationsContainerForCreation"></div>
            <button type="button" id="addNewVariationBtnAddProduct" class="btn btn-secondary mb-4 text-blue-500 underline">
                Add New Variation
            </button>

            <!-- Update your variation combination section -->
            <div id="variationCombinationContainer" class="border-t pt-4">
                <h3 class="mb-2 text-lg font-medium">Variation Combinations</h3>
            </div>

            <!-- Image Upload -->
            <div class="border-t pt-4">
                <label class="mb-2 block text-sm font-medium text-gray-700">Product Images</label>
                <input type="file" id="productImages" name="ProductImages" multiple accept="image/*"
                       onchange="previewImages(this)" class="hidden" />
                <button type="button" onclick="document.getElementById('productImages').click()"
                        class="rounded-md bg-blue-500 px-4 py-2 text-white hover:bg-blue-600">
                    Choose Images
                </button>
                <div id="imagePreviewContainer" class="grid-cols-4 mt-4 grid gap-4"></div>
            </div>

            <div class="flex justify-end space-x-4 border-t pt-4">
                <button type="button" onclick="closeAddProductModal()"
                        class="rounded-md bg-gray-500 px-6 py-2 text-white hover:bg-gray-600">
                    Cancel
                </button>
                <button type="submit"
                        class="rounded-md bg-blue-500 px-6 py-2 text-white hover:bg-blue-600">
                    Create Product
                </button>
            </div>
        </form>
    </div>
</div>

<!-- Edit Product Modal -->
<div id="editProductModal" class="fixed inset-0 hidden items-center justify-center bg-black bg-opacity-50">
    <div class="max-h-[90vh] w-3/4 overflow-y-auto rounded-lg bg-white p-6">
        <h2 class="mb-4 text-center text-2xl font-bold">Edit Product</h2>
        <!-- Image Upload Section -->
        <div class="border-t pt-4">
            <label class="mb-2 block text-sm font-medium text-gray-700">Product Images</label>
            <input type="file" id="productImagesForEdit" name="ProductImages" multiple accept="image/*"
                   onchange="uploadImages(this.files)" class="hidden" />
            <button type="button" onclick="document.getElementById('productImagesForEdit').click()"
                    class="rounded-md bg-blue-500 px-4 py-2 text-white hover:bg-blue-600">
                Choose Images
            </button>
            <div id="imagePreviewContainerForEdit" class="grid-cols-4 mt-4 grid gap-4"></div>
        </div>
        <!-- Basic Information Form -->
        <form method="post" asp-page-handler="UpdateBasicInfo" id="basicInfoForm" class="mb-8 space-y-4 border-b pb-8">
            @Html.AntiForgeryToken()
            <input type="hidden" name="productId" id="editProductId" />
            <div class="grid-cols-2 grid gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Product Name</label>
                    <input type="text" asp-for="ProductUpdate.Name" id="editProductName"
                           class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
                    <span asp-validation-for="ProductUpdate.Name" class="text-sm text-red-500"></span>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Category</label>
                    <select asp-for="ProductUpdate.CategoryId" id="editCategorySelect"
                            asp-items="@(new SelectList(Model.Categories, "Id", "Name"))"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                            id="categorySelectForUpdate">
                        <option value="">Select Category</option>
                    </select>
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">Description</label>
                <textarea asp-for="ProductUpdate.Description" id="editProductDescription" rows="3"
                          class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></textarea>
            </div>
            <div class="flex justify-end">
                <button type="submit"
                        class="rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700">
                    Save Basic Info
                </button>
            </div>
        </form>
        <!-- Product Items Form -->
        <form method="post" asp-page-handler="UpdateProductItems" id="productItemsForm" class="space-y-4">
            @Html.AntiForgeryToken()
            <input type="hidden" name="productId" id="editProductIdForItems" />
            <h3 class="mb-4 text-lg font-medium text-gray-900">Product Items</h3>
            <div id="productItemsContainer" class="space-y-4">
                <!-- Product items will be populated here -->
            </div>
            <div class="mt-4 flex justify-end">
                <button type="button" id="saveProductItemsButton" class="rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700">
                    Save Product Items
                </button>
            </div>
        </form>

        <!-- Add Product Items Section -->
        <form method="post" asp-page-handler="AddProductItems" id="addProductItemsForm" class="space-y-4">
            @Html.AntiForgeryToken()

            <!-- New Variations Section -->
            <div id="newVariationsContainerForUpdate" class="mt-4"></div>
            <button type="button" id="addNewVariationBtnEditProduct" class="btn btn-secondary mb-4 text-blue-500 underline">
                Add New Variation
            </button>

            <div id="variationCombinationContainerForUpdate" class="border-t pt-4">
                <h3 class="mb-2 text-lg font-medium">Variation Combinations</h3>
                <!-- Các kết hợp sẽ được hiển thị tại đây -->
            </div>
        </form>

        <div class="mt-8 flex justify-end space-x-3 border-t pt-4">
            <button type="button" onclick="closeEditModal()"
                    class="rounded-md bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200">
                Close
            </button>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        async function toggleProductStatus(productId, currentStatus, button) {
            try {
                const isAvailable = currentStatus === "Available" ? false : true;
                const response = await fetch(`?handler=ToggleProductStatus&productId=${productId}&isAvailable=${isAvailable}`, {
                    method: 'POST',
                    headers: {
                        '__RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Update the product status label and button text immediately
                    const statusLabel = document.getElementById(`status-label-${productId}`);
                    const newStatus = isAvailable ? "Available" : "Unavailable";
                    statusLabel.textContent = newStatus;

                    // Update the status label class for color change
                    if (isAvailable) {
                        statusLabel.classList.remove("bg-red-100", "text-red-800");
                        statusLabel.classList.add("bg-green-100", "text-green-800");
                    } else {
                        statusLabel.classList.remove("bg-green-100", "text-green-800");
                        statusLabel.classList.add("bg-red-100", "text-red-800");
                    }

                    // Update the button text and style
                    button.textContent = isAvailable ? "Deactivate" : "Activate";
                    button.className = isAvailable ? "bg-yellow-500 hover:bg-yellow-600 text-white py-1 px-3 rounded-md"
                        : "bg-green-500 hover:bg-green-600 text-white py-1 px-3 rounded-md";

                    // Update the button's currentStatus value for next toggle
                    button.setAttribute("onclick", `toggleProductStatus('${productId}', '${newStatus}', this)`);
                } else {
                    alert(data.error || 'Failed to update product status');
                }
            } catch (error) {
                console.error('Error details:', error);
                alert('An unexpected error occurred while updating the product status.');
            }
        }

        // Delete Product Function
        async function deleteProduct(productId) {
            if (!confirm('Are you sure you want to delete this product?')) {
                return;
            }

            try {
                const token = document.querySelector('input[name="__RequestVerificationToken"]').value;
                const response = await fetch(`?handler=DeleteProduct&id=${productId}`, {
                    method: 'POST',
                    headers: {
                        'RequestVerificationToken': token
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete product');
                }

                alert('Product deleted successfully!');
                window.location.reload();
            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while deleting the product');
            }
        }

        //Add Product
        // Global state management
        const state = {
            existingVariationsData: [],
            variationCombinations: []
        };

        // Utility functions
        const generateCombinations = (variations) => {
            if (variations.length === 0) return [];

            const combine = (current, index) => {
                if (index === variations.length) {
                    return [current];
                }

                const results = [];
                const currentVariation = variations[index];

                // Skip variations with no selected options
                if (currentVariation.optionIds.length === 0) {
                    return combine(current, index + 1);
                }

                for (let i = 0; i < currentVariation.optionIds.length; i++) {
                    const newCombination = {
                        ...current,
                        optionIds: [...(current.optionIds || []), currentVariation.optionIds[i]],
                        description: [...(current.description || []),
                        `${currentVariation.variationName}: ${currentVariation.optionNames[i]}`]
                    };
                    results.push(...combine(newCombination, index + 1));
                }

                return results;
            };

            return combine({}, 0);
        };

        const saveNewVariationForCreation = async (variationRow) => {
            try {
                const nameInput = variationRow.querySelector('input[name*=".Name"]');
                const optionInputs = variationRow.querySelectorAll('input[name*=".Options"]');
                const variationName = nameInput.value.trim();
                const options = Array.from(optionInputs).map(input => input.value.trim()).filter(Boolean);

                if (!variationName || options.length === 0) {
                    alert('Please enter variation name and at least one option');
                    return;
                }

                const categoryId = document.getElementById('categorySelect').value;
                const response = await fetch(`?handler=CategoryVariations&categoryId=${categoryId}`);
                const existingVariations = await response.json();
                const existingVariation = existingVariations.find(v =>
                    v.name.toLowerCase() === variationName.toLowerCase()
                );

                let variationId;
                let optionIds = [];

                if (existingVariation) {
                    variationId = existingVariation.id;
                    for (const option of options) {
                        const optionData = {
                            value: option,
                            variationId: variationId
                        };

                        const createOptionResponse = await fetch('?handler=CreateVariationOption', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                            },
                            body: JSON.stringify(optionData)
                        });

                        if (!createOptionResponse.ok) {
                            throw new Error('Failed to create option');
                        }

                        const optionResult = await createOptionResponse.json();
                        if (optionResult.success) {
                            optionIds.push(optionResult.optionId);
                        }
                    }
                } else {
                    const variationData = {
                        name: variationName,
                        categoryId: categoryId,
                        options: options
                    };

                    const createResponse = await fetch('?handler=CreateVariation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify(variationData)
                    });

                    if (!createResponse.ok) {
                        throw new Error('Failed to create variation');
                    }

                    const result = await createResponse.json();
                    if (result.success) {
                        variationId = result.variationId;
                        optionIds = result.optionIds;
                    } else {
                        throw new Error(result.message);
                    }
                }

                appendVariationToList(variationId, variationName, options, optionIds);
                variationRow.remove();
                alert('Variation saved successfully!');
            } catch (error) {
                console.error('Error saving variation:', error);
                alert('Failed to save variation: ' + error.message);
            }
        };

        const appendVariationToList = (variationId, variationName, options, optionIds) => {
            const variationDiv = document.createElement('div');
            variationDiv.classList.add('p-4', 'border', 'rounded-md', 'bg-gray-50', 'mb-4');

            const optionsHtml = options.map((option, index) => `
                                <div class="mt-2 flex items-center">
                                    <input type="checkbox"
                                           name="variation_${variationId}"
                                           value="${optionIds[index]}"
                                           data-option-name="${option}"
                                           data-variation-name="${variationName}"
                                           class="form-checkbox mr-2 h-4 w-4 text-blue-600"
                                           onchange="handleVariationOptionCheck(this)" />
                                    <label class="text-sm text-gray-700">${option}</label>
                                </div>
                            `).join('');

            variationDiv.innerHTML = `
                                <div class="mb-2 flex items-center justify-between">
                                    <span class="font-medium">${variationName}</span>
                                    <button type="button"
                                            onclick="removeExistingVariation('${variationId}')"
                                            class="text-red-600 hover:text-red-800">
                                        Remove
                                    </button>
                                </div>
                                <div class="variation-options">
                                    ${optionsHtml}
                                </div>
                            `;

            document.getElementById('existingVariationsList').appendChild(variationDiv);
        };

        const handleVariationOptionCheck = (checkbox) => {
            try {
                const variationId = checkbox.name.replace('variation_', '');
                const optionId = checkbox.value;
                const variationName = checkbox.getAttribute('data-variation-name');
                const optionName = checkbox.getAttribute('data-option-name');

                let variation = state.existingVariationsData.find(v => v.variationId === variationId);

                if (checkbox.checked) {
                    if (variation) {
                        if (!variation.optionIds.includes(optionId)) {
                            variation.optionIds.push(optionId);
                            variation.optionNames.push(optionName);
                        }
                    } else {
                        state.existingVariationsData.push({
                            variationId,
                            variationName,
                            optionIds: [optionId],
                            optionNames: [optionName]
                        });
                    }
                } else {
                    if (variation) {
                        const optionIndex = variation.optionIds.indexOf(optionId);
                        if (optionIndex > -1) {
                            variation.optionIds.splice(optionIndex, 1);
                            variation.optionNames.splice(optionIndex, 1);
                        }

                        if (variation.optionIds.length === 0) {
                            state.existingVariationsData = state.existingVariationsData.filter(
                                v => v.variationId !== variationId
                            );
                        }
                    }
                }

                updateVariationCombinations();
            } catch (error) {
                console.error('Error handling variation option check:', error);
            }
        };

        const addNewVariationForCreationUI = () => {
            const container = document.getElementById('newVariationsContainerForCreation');
            const variationIndex = container.children.length;

            const newRow = document.createElement('div');
            newRow.classList.add('variation-row', 'mb-4', 'p-4', 'border', 'rounded');
            newRow.innerHTML = `
                                <div class="mb-2 flex items-center">
                                    <label class="mr-2 block text-sm font-medium text-gray-700">Variation Name:</label>
                                    <input type="text"
                                           name="NewVariations[${variationIndex}].Name"
                                           class="form-input mr-2 flex-grow rounded"
                                           placeholder="Enter variation name"
                                           required />
                                    <button type="button"
                                            onclick="this.closest('.variation-row').remove()"
                                            class="text-red-600 hover:text-red-800">
                                        Remove
                                    </button>
                                </div>
                                <div class="variation-options">
                                    <div class="option-row mb-2">
                                        <label class="mb-1 block text-sm font-medium text-gray-700">Options:</label>
                                        <div class="flex items-center">
                                            <input type="text"
                                                   name="NewVariations[${variationIndex}].Options"
                                                   class="form-input mr-2 flex-grow rounded"
                                                   placeholder="Enter option value"
                                                   required />
                                            <button type="button"
                                                    onclick="addVariationOption(this.closest('.option-row'))"
                                                    class="rounded-md bg-blue-500 px-3 py-1 text-white hover:bg-blue-600">
                                                Add Option
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <div class="mt-4">
                                    <button type="button"
                                                    onclick="saveNewVariationForCreation(this.closest('.variation-row'))"
                                            class="rounded-md bg-green-500 px-4 py-2 text-white hover:bg-green-600">
                                        Save Variation
                                    </button>
                                </div>
                            `;

            container.appendChild(newRow);
        };

        const validateInput = {
            price: (value) => {
                const price = parseInt(value);
                return !isNaN(price) && price > 0;
            },
            stock: (value) => {
                const stock = parseInt(value);
                return !isNaN(stock) && stock >= 0;
            }
        };

        // Variation handling functions
        const handleExistingVariationSelection = async (selectElement) => {
            try {
                const variationId = selectElement.getAttribute('data-variation-id');
                const variationName = selectElement.getAttribute('data-variation-name');
                const optionId = selectElement.value;
                const optionName = selectElement.options[selectElement.selectedIndex].text;

                // Update state
                const existingIndex = state.existingVariationsData.findIndex(v => v.variationId === variationId);
                if (existingIndex >= 0) {
                    if (optionId) {
                        state.existingVariationsData[existingIndex] = {
                            variationId,
                            variationName,
                            optionId,
                            optionName
                        };
                    } else {
                        state.existingVariationsData.splice(existingIndex, 1);
                    }
                } else if (optionId) {
                    state.existingVariationsData.push({
                        variationId,
                        variationName,
                        optionId,
                        optionName
                    });
                }

                // Find the form using multiple selectors
                const form = selectElement.closest('form') ||
                    document.querySelector('form') ||
                    document.querySelector('[asp-page-handler="CreateProduct"]');

                if (!form) {
                    console.warn('Form not found, creating hidden input in the select element\'s parent');
                    // If no form is found, add the hidden input to the select's parent container
                    const container = selectElement.closest('.p-4') || selectElement.parentElement;

                    const hiddenInput = container.querySelector(`input[name="variation_${variationId}"]`) ||
                        document.createElement('input');

                    if (optionId) {
                        hiddenInput.type = 'hidden';
                        hiddenInput.name = `variation_${variationId}`;
                        hiddenInput.value = optionId;
                        if (!hiddenInput.parentElement) {
                            container.appendChild(hiddenInput);
                        }
                    } else if (hiddenInput.parentElement) {
                        hiddenInput.remove();
                    }
                } else {
                    // If form is found, proceed with normal hidden input handling
                    const hiddenInput = form.querySelector(`input[name="variation_${variationId}"]`) ||
                        document.createElement('input');

                    if (optionId) {
                        hiddenInput.type = 'hidden';
                        hiddenInput.name = `variation_${variationId}`;
                        hiddenInput.value = optionId;
                        if (!hiddenInput.parentElement) {
                            form.appendChild(hiddenInput);
                        }
                    } else if (hiddenInput.parentElement) {
                        hiddenInput.remove();
                    }
                }

                updateVariationCombinations();
            } catch (error) {
                console.error('Error handling variation selection:', error);
                console.log('Select element:', selectElement);
                console.log('Current state:', state);
                alert('Error updating variation selection. Please try again.');
            }
        };

        const handleNewVariationInput = (input) => {
            try {
                const variationRow = input.closest('.variation-row');
                if (!variationRow) return;

                const nameInput = variationRow.querySelector('input[name*=".Name"]');
                const optionInputs = variationRow.querySelectorAll('input[name*=".Options"]');

                if (!nameInput || !optionInputs.length) return;

                if (nameInput.value) {
                    // Remove existing variation with same name
                    state.selectedVariations = state.selectedVariations.filter(
                        v => v.variationId !== `new_${nameInput.value}`
                    );

                    // Add new options
                    optionInputs.forEach(optionInput => {
                        if (optionInput.value) {
                            state.selectedVariations.push({
                                variationId: `new_${nameInput.value}`,
                                variationName: nameInput.value,
                                optionId: `new_${optionInput.value}`,
                                optionName: optionInput.value
                            });
                        }
                    });

                    updateVariationCombinations();
                }
            } catch (error) {
                console.error('Error handling new variation input:', error);
            }
        };

        const updateVariationCombinations = () => {
            try {
                const container = document.getElementById('variationCombinationContainer');
                if (!container) return;

                container.innerHTML = '<h3 class="mb-2 text-lg font-medium">Variation Combinations</h3>';

                // Only proceed if we have variations with selected options
                const variationsWithOptions = state.existingVariationsData.filter(v => v.optionIds.length > 0);
                if (variationsWithOptions.length === 0) return;

                const combinations = generateCombinations(variationsWithOptions);

                combinations.forEach((combination, index) => {
                    const combinationDiv = document.createElement('div');
                    combinationDiv.classList.add('mb-4', 'p-4', 'border', 'rounded-md');

                    combinationDiv.innerHTML = `
                                        <div class="mb-2 font-medium">${combination.description.join(', ')}</div>
                                        <div class="grid-cols-2 grid gap-4">
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">Price</label>
                                                <input type="number"
                                                       name="VariationCombinations[${index}].Price"
                                                       class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                                       required min="0" step="0.01" />
                                            </div>
                                            <div>
                                                <label class="block text-sm font-medium text-gray-700">Stock</label>
                                                <input type="number"
                                                       name="VariationCombinations[${index}].Stock"
                                                       class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                                       required min="0" step="1" />
                                            </div>
                                        </div>
                                        <input type="hidden"
                                               name="VariationCombinations[${index}].OptionIds"
                                               value="${combination.optionIds.join(',')}" />
                                    `;

                    container.appendChild(combinationDiv);
                });
            } catch (error) {
                console.error('Error updating variation combinations:', error);
            }
        };

        // Category and variation loading
        const loadExistingVariations = async () => {
            try {
                const categoryId = document.getElementById('categorySelect')?.value;
                const container = document.getElementById('existingVariationsList');

                if (!container) return;
                container.innerHTML = '';

                if (!categoryId) return;

                const response = await fetch(`?handler=CategoryVariations&categoryId=${categoryId}`);
                if (!response.ok) throw new Error('Failed to load variations');

                const variations = await response.json();
                const variationNamesSet = new Set(); // Track unique variation names

                for (const variation of variations) {
                    // Skip if the variation name already exists
                    if (variationNamesSet.has(variation.name)) continue;
                    variationNamesSet.add(variation.name);

                    const variationDiv = document.createElement('div');
                    variationDiv.classList.add('p-4', 'border', 'rounded-md', 'bg-gray-50', 'mb-4');

                    variationDiv.innerHTML = `
                                        <div class="mb-2 flex items-center justify-between">
                                            <span class="font-medium">${variation.name}</span>
                                            <button type="button"
                                                    onclick="removeExistingVariation('${variation.id}')"
                                                    class="text-red-600 hover:text-red-800">
                                                Remove
                                            </button>
                                        </div>
                                        <div class="variation-options mt-2" id="options-${variation.id}">
                                            <div class="grid-cols-2 grid gap-2">
                                                <!-- Options will be loaded here -->
                                            </div>
                                        </div>
                                    `;

                    container.appendChild(variationDiv);
                    await loadVariationOptions(variation.id, variation.name);
                }
            } catch (error) {
                console.error('Error loading variations:', error);
                alert('Failed to load existing variations');
            }
        };

        const loadVariationOptions = async (variationId, variationName) => {
            try {
                const response = await fetch(`?handler=VariationOptions&variationId=${variationId}`);
                if (!response.ok) throw new Error('Failed to load variation options');

                const options = await response.json();
                const optionsContainer = document.getElementById(`options-${variationId}`).querySelector('.grid');
                const optionValuesSet = new Set(); // Track unique option values for this variation

                options.forEach(option => {
                    // Skip if the option value already exists for this variation
                    if (optionValuesSet.has(option.value)) return;
                    optionValuesSet.add(option.value);

                    const optionDiv = document.createElement('div');
                    optionDiv.classList.add('flex', 'items-center');
                    optionDiv.innerHTML = `
                                        <input type="checkbox"
                                               id="option-${option.id}"
                                               name="variation_${variationId}"
                                               value="${option.id}"
                                               data-variation-id="${variationId}"
                                               data-variation-name="${variationName}"
                                               data-option-name="${option.value}"
                                               class="form-checkbox mr-2 h-4 w-4 text-blue-600"
                                               onchange="handleVariationOptionCheck(this)" />
                                        <label for="option-${option.id}" class="text-sm text-gray-700">${option.value}</label>
                                    `;
                    optionsContainer.appendChild(optionDiv);
                });
            } catch (error) {
                console.error('Error loading variation options:', error);
                alert('Failed to load variation options');
            }
        };

        // Initialize everything when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const categorySelect = document.getElementById('categorySelect');
            if (categorySelect) {
                categorySelect.addEventListener('change', loadExistingVariations);
                if (categorySelect.value) {
                    loadExistingVariations();
                }
            }

            const addNewVariationBtnAddProduct = document.getElementById('addNewVariationBtnAddProduct');
            if (addNewVariationBtnAddProduct) {
                addNewVariationBtnAddProduct.addEventListener('click', addNewVariationForCreationUI);
            }

            const addNewVariationBtnEditProduct = document.getElementById('addNewVariationBtnEditProduct');
            if (addNewVariationBtnEditProduct) {
                addNewVariationBtnEditProduct.addEventListener('click', addNewVariationForUpdateUI);
            }

            const form = document.querySelector('form[asp-page-handler="CreateProduct"]');
            if (form) {
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (await validateForm()) {
                        await submitForm(form);
                    }
                });
            }
        });

        // Form validation and submission
        const validateForm = async (event) => {
            const name = document.querySelector('input[asp-for="ProductCreation.Name"]')?.value;
            const category = document.querySelector('select[asp-for="ProductCreation.CategoryId"]')?.value;

            // Validate required fields: Name and Category
            if (!name || !category) {
                alert('Please fill in all required fields (Name and Category)');
                return false;
            }

            const hasVariations = state.existingVariationsData.length > 0;
            if (!hasVariations) {
                alert('Please select at least one variation option');
                return false;
            }

            const combinations = document.querySelectorAll('#variationCombinationContainer > div');
            if (!combinations.length) {
                alert('Please create at least one variation combination');
                return false;
            }

            let isValid = true;
            combinations.forEach(combo => {
                const price = combo.querySelector('input[name*=".Price"]')?.value;
                const stock = combo.querySelector('input[name*=".Stock"]')?.value;

                // Validate price and stock
                if (!validateInput.price(price) || !validateInput.stock(stock)) {
                    isValid = false;
                }
            });

            // File validation for images (manual validation)
            const fileInput = document.getElementById('productImages');
            const imagePreviewContainer = document.getElementById('imagePreviewContainer');

            console.log(fileInput.files.length)

            if (fileInput.files.length === 0) {
                alert('Please upload at least one product image.');
                return false; // Prevent form submission if no images are selected
            } else {
                // If files are selected, update the preview
                imagePreviewContainer.innerHTML = ''; // Clear any previous previews
                previewImages(fileInput); // Call the preview function
            }

            // If price/stock is invalid, return false
            if (!isValid) {
                alert('Please enter valid price and stock for all variation combinations');
                return false;
            }

            return true;
        };


        const submitForm = async (form) => {
            try {
                const formData = new FormData(form);

                // Get basic product info
                const productData = {
                    name: formData.get('ProductCreation.Name'),
                    description: formData.get('ProductCreation.Description'),
                    categoryId: formData.get('ProductCreation.CategoryId'),
                    variations: [],
                    variationCombinations: []
                };

                // Format variations
                const variationIds = formData.getAll('variation_id');
                const variationOptionIds = formData.getAll('variation_option_id');

                for (let i = 0; i < variationIds.length; i++) {
                    productData.variations.push({
                        id: variationIds[i],
                        variationOptionIds: variationOptionIds
                            .filter((_, index) => index % variationIds.length === i)
                            .map(id => id.trim())
                    });
                }

                // Format variation combinations
                const combinationCount = formData.getAll('VariationCombinations[].Price').length;
                for (let i = 0; i < combinationCount; i++) {
                    productData.variationCombinations.push({
                        variationOptionIds: formData.getAll(`VariationCombinations[${i}].OptionIds`)
                            .map(id => id.trim()),
                        price: parseInt(formData.get(`VariationCombinations[${i}].Price`)),
                        quantityInStock: parseInt(formData.get(`VariationCombinations[${i}].Stock`))
                    });
                }

                // Log the formatted data for debugging
                console.log('Product Data being sent:', JSON.stringify(productData, null, 2));

                // Validate the data structure
                if (!validateProductData(productData)) {
                    throw new Error('Invalid product data structure');
                }

                const response = await fetch('?handler=CreateProduct', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    },
                    body: JSON.stringify(productData)
                });

                const result = await response.json();
                console.log('API Response:', result);

                if (response.redirected) {
                    window.location.href = response.url;
                    return;
                }

                if (result.success) {
                    alert('Product created successfully!');
                    window.location.reload();
                } else {
                    alert(result.message || 'Failed to create product. Please try again.');
                }
            } catch (error) {
                console.error('Error submitting form:', error);
                alert('An error occurred while creating the product. Please try again.');
            }
        };

        const validateProductData = (data) => {
            console.log('Validating product data:', data);

            // Basic validation
            if (!data.name || !data.categoryId) {
                console.error('Missing required fields: name or categoryId');
                return false;
            }

            // Validate variations
            if (!Array.isArray(data.variations) || data.variations.length === 0) {
                console.error('No variations specified');
                return false;
            }

            // Validate variation structure
            const validVariations = data.variations.every(variation => {
                const isValid = variation.id &&
                    Array.isArray(variation.variationOptionIds) &&
                    variation.variationOptionIds.length > 0;

                if (!isValid) {
                    console.error('Invalid variation structure:', variation);
                }
                return isValid;
            });

            if (!validVariations) {
                return false;
            }

            // Validate combinations
            if (!Array.isArray(data.variationCombinations) || data.variationCombinations.length === 0) {
                console.error('No variation combinations specified');
                return false;
            }

            // Validate combination structure
            const validCombinations = data.variationCombinations.every(combo => {
                const isValid = Array.isArray(combo.variationOptionIds) &&
                    combo.variationOptionIds.length > 0 &&
                    typeof combo.price === 'number' &&
                    combo.price > 0 &&
                    typeof combo.quantityInStock === 'number' &&
                    combo.quantityInStock >= 0;

                if (!isValid) {
                    console.error('Invalid combination structure:', combo);
                }
                return isValid;
            });

            if (!validCombinations) {
                return false;
            }

            return true;
        };

        // Additional helper functions (continued)
        function addVariationOption(optionRow) {
            const variationOptions = optionRow.closest('.variation-options');
            const variationIndex = optionRow.closest('.variation-row').getAttribute('data-variation-index') ||
                optionRow.closest('.variation-row').querySelectorAll('.option-row').length;

            const newOptionRow = document.createElement('div');
            newOptionRow.classList.add('option-row', 'mb-2');

            newOptionRow.innerHTML = `
                                <div class="flex items-center">
                                    <input type="text"
                                           name="NewVariations[${variationIndex}].Options"
                                           class="form-input mr-2 flex-grow rounded"
                                           placeholder="Enter option value"
                                           required
                                           onchange="handleNewVariationInput(this)" />
                                    <button type="button"
                                            onclick="this.closest('.option-row').remove(); updateVariationCombinations();"
                                            class="text-red-600 hover:text-red-800">
                                        Remove
                                    </button>
                                </div>
                            `;

            variationOptions.appendChild(newOptionRow);
        }

        const removeExistingVariation = (variationId) => {
            try {
                // Remove from state
                state.existingVariationsData = state.existingVariationsData.filter(
                    v => v.variationId !== variationId
                );

                // Remove the entire variation div from DOM
                const variationDiv = document.querySelector(`#existingVariationsList div:has(input[name="variation_${variationId}"])`);
                if (variationDiv) {
                    variationDiv.remove();
                }

                updateVariationCombinations();
            } catch (error) {
                console.error('Error removing variation:', error);
            }
        };

        function displayCurrentImages(images) {
            const container = document.getElementById('currentImagesContainer');
            if (!container) {
                console.error('Current images container not found');
                return;
            }

            // Clear existing images
            container.innerHTML = '';

            // Display each image
            images.forEach((image, index) => {
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'relative';

                const img = document.createElement('img');
                img.src = image.imageUrl; // Adjust this based on your image object structure
                img.alt = `Product Image ${index + 1}`;
                img.className = 'w-full h-32 object-cover rounded-md';

                // Delete button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'absolute top-0 right-0 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center m-1';
                deleteButton.innerHTML = '×';
                deleteButton.onclick = () => removeImage(image.id); // Adjust based on your image object structure

                imageWrapper.appendChild(img);
                imageWrapper.appendChild(deleteButton);
                container.appendChild(imageWrapper);
            });
        }

        function removeImage(imageId) {
            if (confirm('Are you sure you want to remove this image?')) {
                // Add your image removal logic here
                console.log(`Removing image with ID: ${imageId}`);
            }
        }

        // Image preview functionality
        function previewImages(input) {
            const imagePreviewContainer = document.getElementById('imagePreviewContainer');
            imagePreviewContainer.innerHTML = '';

            if (input.files) {
                Array.from(input.files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const imgWrapper = document.createElement('div');
                        imgWrapper.classList.add('relative');
                        imgWrapper.innerHTML = `
                                                        <img src="${e.target.result}" class="h-32 w-full rounded-md object-cover" />
                                                        <button type="button" onclick="removeImage(this)"
                                                                class="absolute right-1 top-1 flex h-6 w-6 items-center justify-center rounded-full bg-red-500 text-white">
                                                            ✖
                                                        </button>
                                                    `;
                        imagePreviewContainer.appendChild(imgWrapper);
                    };
                    reader.readAsDataURL(file);
                });
            }
        }

        // Function to remove an image from preview
        function removeImage(button) {
            const imgWrapper = button.closest('div');
            const fileInput = document.getElementById('productImages');
            const files = Array.from(fileInput.files);

            // Remove the corresponding file from FileList
            const index = Array.from(imgWrapper.parentNode.children).indexOf(imgWrapper);
            files.splice(index, 1);

            // Update FileList
            const dataTransfer = new DataTransfer();
            files.forEach(file => dataTransfer.items.add(file));
            fileInput.files = dataTransfer.files;

            // Remove preview
            imgWrapper.remove();
        }

        // Modal functionality
        function openAddProductModal() {
            document.getElementById('addProductModal').classList.remove('hidden');
            document.getElementById('addProductModal').classList.add('flex');
        }

        function closeAddProductModal() {
            // Hide the modal
            document.getElementById("addProductModal").classList.add("hidden");

            // Ensure form is accessible when modal is closed
            const form = document.querySelector("#addProductModal form");

            if (form) {
                form.reset(); // Reset form values
            } else {
                console.error("Form not found.");
            }

            // Clear dynamically generated content
            document.getElementById("existingVariationsList").innerHTML = ""; // Clear Existing Variations
            document.getElementById("newVariationsContainerForCreation").innerHTML = ""; // Clear New Variations
            document.getElementById("variationCombinationContainer").innerHTML = ""; // Clear Variation Combinations

            // Clear image previews
            document.getElementById("imagePreviewContainer").innerHTML = ""; // Clear image preview container
            document.getElementById("productImages").value = ""; // Clear selected files

            // Optional: Remove any custom classes or states if necessary
        }












        //Success Or Not Success modal
        function showSuccessModal() {
            document.getElementById('successModal').classList.remove('hidden');
        }

        function closeSuccessModal() {
            document.getElementById('successModal').classList.add('hidden');
        }




















        //Edit Product
        // Assuming `productId` is available, either passed or retrieved dynamically
        async function loadProductImagesForEdit(productId) {
            const imagePreviewContainer = document.getElementById('imagePreviewContainerForEdit');
            try {
                const response = await fetch(`${apiBaseUrl}/api/productimage/getimage/${productId}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`,
                        'RequestVerificationToken': requestVerificationToken
                    }
                });

                const data = await response.json();

                if (data.statusCode === 200 && data.data) {
                    // Clear previous images
                    imagePreviewContainer.innerHTML = '';

                    // Display each image as a preview
                    data.data.forEach(image => {
                        const imgWrapper = document.createElement('div');
                        imgWrapper.classList.add('relative');
                        imgWrapper.innerHTML = `
                                            <img src="${image.url}" class="h-32 w-full rounded-md object-cover" />
                                            <button type="button" onclick="removeImageForEdit(this, '${image.id}')"
                                                    class="absolute right-1 top-1 flex h-6 w-6 items-center justify-center rounded-full bg-red-500 text-white">
                                                ✖
                                            </button>
                                        `;
                        imagePreviewContainer.appendChild(imgWrapper);
                    });
                } else {
                    console.log('Failed to fetch images:', data.message);
                }
            } catch (error) {
                console.error('Error fetching product images:', error);
            }
        }

        async function removeImageForEdit(button, imageId) {
            // Show confirmation dialog before deletion
            const isConfirmed = window.confirm('Are you sure you want to delete this image?');

            if (!isConfirmed) {
                // If the user cancels, stop the deletion process
                return;
            }

            try {
                const response = await fetch(`${apiBaseUrl}/api/productimage/delete/${imageId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`,
                        'RequestVerificationToken': requestVerificationToken
                    }
                });

                const data = await response.json();

                if (data.statusCode === 200) {
                    // Remove the image preview from the UI
                    const imgWrapper = button.closest('div');
                    imgWrapper.remove();
                    console.log(`Image with ID: ${imageId} removed successfully.`);
                } else {
                    console.log('Failed to remove image:', data.message);
                }
            } catch (error) {
                console.error('Error removing image:', error);
            }
        }

        async function uploadImages(files) {
            const productId = document.getElementById('editProductId').value;
            const formData = new FormData();

            // Thêm các tệp vào FormData
            Array.from(files).forEach(file => {
                formData.append('files', file); // 'files' là tên trường mà API của bạn mong đợi
            });

            try {
                const response = await fetch(`${apiBaseUrl}/api/productimage/upload/${productId}`, {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'Authorization': `Bearer ${authToken}`, // Token xác thực
                        'RequestVerificationToken': requestVerificationToken // Token CSRF
                    }
                });

                const data = await response.json();

                if (data.statusCode === 200 && data.data) {
                    console.log('Images uploaded successfully');
                    loadProductImagesForEdit(productId);
                    // Có thể làm mới hình ảnh đã tải lên hoặc thông báo thành công
                } else {
                    console.log('Failed to upload images:', data.message);
                }
            } catch (error) {
                console.error('Error uploading images:', error);
            }
        }

        const editProductState = {
            productItems: []
        };

        const addNewVariationForUpdateUI = async () => {
            const container = document.getElementById('newVariationsContainerForUpdate');
            const variationIndex = container.children.length;

            const newRow = document.createElement('div');
            newRow.classList.add('variation-row', 'mb-4', 'p-4', 'border', 'rounded');
            newRow.innerHTML = `
                                                <div class="mb-2 flex items-center">
                                                    <label class="mr-2 block text-sm font-medium text-gray-700">Variation Name:</label>
                                                    <input type="text"
                                                           name="NewVariations[${variationIndex}].Name"
                                                           class="form-input mr-2 flex-grow rounded"
                                                           placeholder="Enter variation name"
                                                           required />
                                                    <button type="button"
                                                            onclick="this.closest('.variation-row').remove()"
                                                            class="text-red-600 hover:text-red-800">
                                                        Remove
                                                    </button>
                                                </div>
                                                <div class="variation-options">
                                                    <div class="option-row mb-2">
                                                        <label class="mb-1 block text-sm font-medium text-gray-700">Options:</label>
                                                        <div class="flex items-center">
                                                            <input type="text"
                                                                   name="NewVariations[${variationIndex}].Options"
                                                                   class="form-input mr-2 flex-grow rounded"
                                                                   placeholder="Enter option value"
                                                                   required />
                                                            <button type="button"
                                                                    onclick="addVariationOption(this.closest('.option-row'))"
                                                                    class="rounded-md bg-blue-500 px-3 py-1 text-white hover:bg-blue-600">
                                                                Add Option
                                                            </button>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="mt-4">
                                                    <button type="button"
                                                            onclick="saveNewVariationForUpdate(this.closest('.variation-row'))"
                                                            class="rounded-md bg-green-500 px-4 py-2 text-white hover:bg-green-600">
                                                        Save Variation
                                                    </button>
                                                </div>
                                            `;

            container.appendChild(newRow);
        };

        let combinations = []; // Declare a global variable to store the combinations

        const saveNewVariationForUpdate = async (variationRow) => {
            try {
                const nameInput = variationRow.querySelector('input[name*=".Name"]');
                const optionInputs = variationRow.querySelectorAll('input[name*=".Options"]');

                const variationName = nameInput.value.trim();
                const options = Array.from(optionInputs).map(input => input.value.trim()).filter(Boolean);

                if (!variationName || options.length === 0) {
                    alert('Please enter variation name and at least one option');
                    return;
                }

                const categoryId = document.getElementById('editCategorySelect').value;

                // Create the new variation
                const variationData = { name: variationName, categoryId: categoryId, options: options };

                const createResponse = await fetch('?handler=CreateVariation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(variationData)
                });

                if (!createResponse.ok) {
                    throw new Error('Failed to create variation');
                }

                const result = await createResponse.json();

                const optionIds = result.optionIds;

                // Add the new variation options to the current list of variation options
                const combinedOptions = [...currentVariationOptions];

                optionIds.forEach(optionId => {
                    const optionExists = currentVariationOptions.some(option => option.varitaionName === variationName);

                    if (!optionExists) {
                        combinedOptions.push({ variationName: variationName, optionName: options.join(', '), optionId });
                    }
                });

                // Generate combinations based on the newly created variation
                const combinationContainer = document.getElementById('variationCombinationContainerForUpdate');

                const combinationSection = document.createElement('div');
                combinationSection.classList.add('combination-section', 'mb-4', 'p-4', 'border', 'rounded');

                let combinationHTML = `
                                    <h4 class="text-lg font-medium">Variation Combination</h4>
                                    <div class="grid-cols-1 grid gap-4">
                                `;

                let combinationCounter = 0; // Declare a counter to generate unique IDs

                combinedOptions.forEach((currentOption, currentIdx) => {
                    if (currentOption.variationName.toLowerCase() === variationName.toLowerCase()) {
                        console.log("Skipping combination because variationName matches currentOption.variationName:", variationName);
                        return; // Skip if the variationName matches currentOption.variationName
                    }

                    options.forEach((newOption, newIdx) => {
                        // Use the combination counter for the combinationId
                        const combinationId = `combination-${combinationCounter++}`;  // Increment the counter for each new combination

                        combinationHTML += `
                                    <div class="flex gap-4">
                                        <div class="flex-1">
                                            <label class="block text-sm font-medium text-gray-700">Variation Options</label>
                                            <p class="mt-1 block w-full rounded-md border-gray-300 bg-gray-50 p-2 shadow-sm">
                                                ${currentOption.optionName}, ${newOption}
                                            </p>
                                        </div>
                                        <div class="flex-1">
                                            <label class="block text-sm font-medium text-gray-700">Price</label>
                                            <input type="number"
                                                id="price-${combinationId}"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                                placeholder="Enter price"
                                                min="0" required />
                                        </div>
                                        <div class="flex-1">
                                            <label class="block text-sm font-medium text-gray-700">Quantity In Stock</label>
                                            <input type="number"
                                                id="quantity-${combinationId}"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                                placeholder="Enter quantity"
                                                min="0" required />
                                        </div>
                                    </div>
                                `;

                        // Store the combination data in the global array
                        combinations.push({
                            variationOptions: [currentOption.optionId, optionIds[0]], // Store optionIds
                            price: null,  // Placeholder for price (to be filled later)
                            quantity: null // Placeholder for quantity (to be filled later)
                        });
                    });
                });

                combinationHTML += `</div>`;

                combinationHTML += `
                                    <div class="mt-4 flex justify-end">
                                        <button type="button"
                                                class="rounded-md bg-blue-600 px-4 py-2 text-white hover:bg-blue-700"
                                                onclick="saveVariationCombination()">Save Combination</button>
                                    </div>
                                `;

                combinationSection.innerHTML = combinationHTML;
                combinationContainer.appendChild(combinationSection);

                variationRow.remove(); // Optionally remove the new variation row from the UI

                console.log(combinations);

            } catch (error) {
                console.error('Error saving variation:', error);
                alert('Failed to save variation: ' + error.message);
            }
        };

        const saveVariationCombination = async () => {
            try {
                const productId = document.getElementById('editProductId').value.trim();

                if (!productId) {
                    alert('Product ID is required');
                    return;
                }

                // Create an array to hold all the variation combinations
                const variationCombinations = [];

                // Loop through the global combinations array to collect price and quantity
                for (let i = 0; i < combinations.length; i++) {
                    const combination = combinations[i];
                    const combinationId = `combination-${i}`;
                    const priceInput = document.getElementById(`price-${combinationId}`);
                    const quantityInput = document.getElementById(`quantity-${combinationId}`);

                    // Validate and capture price and quantity
                    const price = parseFloat(priceInput.value.trim());
                    const quantity = parseInt(quantityInput.value.trim(), 10);

                    if (isNaN(price) || price <= 0) {
                        alert(`Please enter a valid price for combination ${i + 1}`);
                        return;
                    }

                    if (isNaN(quantity) || quantity < 0) {
                        alert(`Please enter a valid quantity for combination ${i + 1}`);
                        return;
                    }

                    // Push the validated combination to the array in the correct format
                    variationCombinations.push({
                        VariationOptionIds: combination.variationOptions, // Array of option IDs
                        Price: price,                                     // Price of the combination
                        QuantityInStock: quantity                         // Quantity in stock
                    });
                }

                // If no combinations to save, show a message and return
                if (variationCombinations.length === 0) {
                    alert('No valid variation combinations to save');
                    return;
                }

                // Prepare the data to send in the request
                const variationCombinationDto = variationCombinations; // Directly use the array of combinations

                console.log(variationCombinationDto)

                // Send all the combinations in one POST request
                const response = await fetch(`${apiBaseUrl}/api/productitem/${productId}/items`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`,
                        'RequestVerificationToken': requestVerificationToken
                    },
                    body: JSON.stringify(variationCombinationDto) // Sending the array directly
                });

                if (!response.ok) {
                    const errorResponse = await response.text();
                    console.error('Error Response:', errorResponse);
                    alert(`Failed to save variation combinations: ${errorResponse}`);
                } else {
                    const result = await response.json();
                    console.log(result.message || 'Variation combinations saved successfully!');
                }

                alert('All variation combinations have been saved successfully!');

                combinations = [];

                // Clear the container holding the new variations
                const newVariationsContainer = document.getElementById('newVariationsContainerForUpdate');
                if (newVariationsContainer) {
                    newVariationsContainer.innerHTML = '';
                }

                // Clear the container holding the variation combinations
                const combinationContainer = document.getElementById('variationCombinationContainerForUpdate');
                if (combinationContainer) {
                    combinationContainer.innerHTML = '';
                }

                loadProductDetails(productId);

            } catch (error) {
                console.error('Error saving combination:', error);
                alert('Failed to save combination: ' + error.message);
            }
        };

        async function loadProductDetails(productId) {
            try {
                const response = await fetch(`?handler=ProductDetails&productId=${productId}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });
                if (!response.ok) {
                    throw new Error('Failed to load product data');
                }
                const data = await response.json();
                if (data.success && data.product) {
                    populateEditForm(data.product);
                    populateProductItems(data.product.productItems);
                    openEditProductModal();
                }
            } catch (error) {
                console.error('Error loading product details:', error);
                alert('Failed to load product details: ' + error.message);
            }
        }

        // Assuming product items data is available in editProductState.productItems
        editProductState.productItems.forEach((item, index) => {
            const itemId = formData.get(`ProductItemUpdates[${index}].Id`);  // This should refer to productItemId
            const quantityInput = formData.get(`ProductItemUpdates[${index}].QuantityInStock`);
            const priceInput = formData.get(`ProductItemUpdates[${index}].Price`);

            if (itemId && ((quantityInput !== '' && quantityInput !== null) ||
                (priceInput !== '' && priceInput !== null))) {
                const update = { Id: itemId };  // Set this as the unique productItemId

                if (quantityInput !== '' && quantityInput !== null) {
                    update.QuantityInStock = parseInt(quantityInput);
                }
                if (priceInput !== '' && priceInput !== null) {
                    update.Price = parseInt(priceInput);
                }

                updates.push(update);
            }
        });

        let currentVariationOptions = [];

        function populateProductItems(productItems) {
            const container = document.getElementById('productItemsContainer');
            container.innerHTML = '';
            editProductState.productItems = productItems || [];

            // Clear and store all the existing variation options globally
            currentVariationOptions = [];

            // Store current variation options from all product items
            editProductState.productItems.forEach((item, index) => {
                const variationOptions = item.configurations.map(config => config.optionName);

                item.configurations.forEach(config => {
                    // Check if variationName and optionName already exist in currentVariationOptions
                    const optionExists = currentVariationOptions.some(option =>
                        option.variationName === config.variationName && option.optionName === config.optionName
                    );

                    // Add only if it doesn't already exist
                    if (!optionExists) {
                        currentVariationOptions.push({
                            variationName: config.variationName,
                            optionName: config.optionName,
                            optionId: config.optionId
                        });
                    }
                });

                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-4 border rounded-md product-item';

                const isLastItem = editProductState.productItems.length === 1;

                itemDiv.innerHTML = `
                                    <input type="hidden" name="ProductItemUpdates[${index}].Id" value="${item.id}" />
                                    <div class="flex gap-4">
                                        <div class="flex-1">
                                            <label class="block text-sm font-medium text-gray-700">Variation Options</label>
                                            <p class="mt-1 block w-full rounded-md border-gray-300 bg-gray-50 p-2 shadow-sm">${variationOptions.join(', ')}</p>
                                        </div>
                                        <div class="flex-1">
                                            <label class="block text-sm font-medium text-gray-700">Quantity in Stock</label>
                                            <input type="number"
                                                name="ProductItemUpdates[${index}].QuantityInStock"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                                value="${item.quantityInStock}"
                                                min="0" />
                                        </div>
                                        <div class="flex-1">
                                            <label class="block text-sm font-medium text-gray-700">Price</label>
                                            <input type="number"
                                                name="ProductItemUpdates[${index}].Price"
                                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                                value="${item.price}"
                                                min="0" />
                                        </div>
                                        <div class="flex items-center justify-center">
                                            <button class="text-red-600 ${isLastItem ? 'cursor-not-allowed opacity-50' : ''}"
                                                onclick="${isLastItem ? 'return false;' : `deleteProductItem(${index})`}">
                                                <i class="fas fa-trash-alt"></i>
                                                Delete
                                            </button>
                                        </div>
                                    </div>
                                `;

                container.appendChild(itemDiv);
            });
        }

        document.getElementById('saveProductItemsButton').addEventListener('click', async () => {
            const productItemsContainer = document.getElementById('productItemsContainer');
            const productItemDivs = productItemsContainer.querySelectorAll('.product-item');

            const requests = Array.from(productItemDivs).map(async (itemDiv, index) => {
                const id = itemDiv.querySelector('input[name="ProductItemUpdates[' + index + '].Id"]').value;
                const quantityInStock = itemDiv.querySelector('input[name="ProductItemUpdates[' + index + '].QuantityInStock"]').value;
                const price = itemDiv.querySelector('input[name="ProductItemUpdates[' + index + '].Price"]').value;

                const productItem = editProductState.productItems.find(item => item.id == id);

                // Kiểm tra xem có thay đổi giá trị không
                const quantityChanged = productItem.quantityInStock !== parseInt(quantityInStock, 10);
                const priceChanged = productItem.price !== parseFloat(price);

                if (!quantityChanged && !priceChanged) {
                    return; // Nếu không có thay đổi, bỏ qua việc cập nhật
                }

                // Tạo DTO cập nhật
                const updatedProductItemDto = {
                    QuantityInStock: parseInt(quantityInStock, 10),
                    Price: parseFloat(price),
                };

                try {
                    const response = await fetch(`${apiBaseUrl}/api/ProductItem/${id}`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`,
                            'RequestVerificationToken': requestVerificationToken
                        },
                        body: JSON.stringify(updatedProductItemDto)
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to update ProductItem with ID ${id}`);
                    }

                    console.log(`Successfully updated ProductItem with ID ${id}`);
                } catch (error) {
                    console.error(error.message);
                }
            });

            // Đợi tất cả các yêu cầu cập nhật hoàn thành
            await Promise.all(requests);
            alert('Product items update completed.');
        });

        async function deleteProductItem(index) {
            // Confirm before proceeding with delete
            const confirmed = confirm("Are you sure you want to delete this product item?");
            if (!confirmed) {
                return; // Exit if the user does not confirm
            }

            const productItem = editProductState.productItems[index];
            const productItemId = productItem.id;

            try {
                // Gọi API DELETE ngay khi ấn nút Delete
                const response = await fetch(`${apiBaseUrl}/api/productitem/${productItemId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`, // Thêm token nếu cần
                        'RequestVerificationToken': requestVerificationToken
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to delete ProductItem with ID ${productItemId}`);
                }

                console.log(`Successfully deleted ProductItem with ID ${productItemId}`);

                // Cập nhật trạng thái UI để phản ánh việc xóa thành công
                const itemDiv = document.querySelectorAll('.product-item')[index];
                itemDiv.classList.add('bg-gray-100'); // Thêm nền xám cho item đã xóa
                itemDiv.querySelector('button').disabled = true; // Vô hiệu hóa nút xóa (để tránh nhấn lại)
                itemDiv.querySelector('input[name^="ProductItemUpdates"]').disabled = true; // Vô hiệu hóa các input trong item

                // Đánh dấu sản phẩm là đã xóa
                productItem.deletedBy = true;
                productItem.deletedTime = new Date().toISOString();

                // Remove the deleted product item from the list
                editProductState.productItems.splice(index, 1);

                // Hiển thị lại danh sách để phản ánh sự thay đổi
                populateProductItems(editProductState.productItems);

            } catch (error) {
                console.error(error.message);
            }
        }

        function populateEditForm(product) {
            if (!product) return;
            document.getElementById('editProductId').value = product.id;
            document.getElementById('editProductIdForItems').value = product.id;

            // Clear all inputs first
            document.getElementById('editProductName').value = '';
            document.getElementById('editProductDescription').value = '';
            document.getElementById('editCategorySelect').value = '';

            // Only populate fields that exist in the product
            if (product.name) document.getElementById('editProductName').value = product.name;
            if (product.description) document.getElementById('editProductDescription').value = product.description;
            if (product.categoryId) document.getElementById('editCategorySelect').value = product.categoryId;
        }

        function openEditProductModal() {
            const modal = document.getElementById('editProductModal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');

            const productId = document.getElementById('editProductId').value.trim();

            // Load the product images
            loadProductImagesForEdit(productId);

            // Show the modal (assuming you're using CSS classes to show/hide the modal)
            document.getElementById('editProductModal').classList.remove('hidden');
        }

        function closeEditModal() {
            // Ẩn modal
            const modal = document.getElementById('editProductModal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            combinations = [];

            // Clear the container holding the new variations
            const newVariationsContainer = document.getElementById('newVariationsContainerForUpdate');
            if (newVariationsContainer) {
                newVariationsContainer.innerHTML = '';
            }

            // Clear the container holding the variation combinations
            const combinationContainer = document.getElementById('variationCombinationContainerForUpdate');
            if (combinationContainer) {
                combinationContainer.innerHTML = '';
            }
            // Clear tất cả các trường input trong form
            const form = modal.querySelector('form');
            form.reset(); // Reset tất cả các trường trong form

            // Đặt lại các thuộc tính của editProductState mà không gán lại đối tượng
            editProductState.productItems = [];
        }

        // Add form submission handlers
        document.getElementById('basicInfoForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const form = e.target;
            const formData = new FormData(form);
            const productId = formData.get('productId');

            // Create an object with only the modified fields
            const updateData = {};
            if (formData.get('ProductUpdate.Name')) updateData['Name'] = formData.get('ProductUpdate.Name');
            if (formData.get('ProductUpdate.Description')) updateData['Description'] = formData.get('ProductUpdate.Description');
            if (formData.get('ProductUpdate.CategoryId')) updateData['CategoryId'] = formData.get('ProductUpdate.CategoryId');

            try {
                const response = await fetch(`?handler=UpdateBasicInfo&productId=${productId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    },
                    body: JSON.stringify({
                        productId: productId,
                        productUpdate: updateData
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        alert('Product information updated successfully');
                        closeEditModal();
                        location.reload();
                    } else {
                        alert(result.message || 'Failed to update product information');
                    }
                } else {
                    alert('An error occurred while updating the product');
                }
            } catch (error) {
                console.error('Error updating product:', error);
                alert('An error occurred while updating the product');
            }
        });

        // Sending form data to the backend as JSON
        document.getElementById('productItemsForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const updates = [];

            editProductState.productItems.forEach((item, index) => {
                const itemId = formData.get(`ProductItemUpdates[${index}].Id`);
                const quantityInput = formData.get(`ProductItemUpdates[${index}].QuantityInStock`);
                const priceInput = formData.get(`ProductItemUpdates[${index}].Price`);

                if (itemId && ((quantityInput !== '' && quantityInput !== null) ||
                    (priceInput !== '' && priceInput !== null))) {
                    const update = { Id: itemId };
                    if (quantityInput) update.QuantityInStock = parseInt(quantityInput);
                    if (priceInput) update.Price = parseInt(priceInput);

                    updates.push(update);
                }
            });
        });
    </script>
}